---
sidebar_position: 9
---

# XACK

The `XACK` command removes one or more messages from a Redis Stream **Pending Entries List (PEL)**, marking them as acknowledged for a given consumer group.


## Syntax
```
XACK key group id [id ...]
```


## Before Acknowledgement (Manual)
Assume in our previous example you haven’t implemented any acknowledgment logic yet:

```java
for (MapRecord<String, Object, Object> record : records) {
    String streamId = record.getId().getValue();

    if (!repository.existsByStreamId(streamId)) {
        RaceStreamEntity entity = toEntity(record);
        repository.save(entity);

        //@TODO: Acknowledge after successful save
    } else {
        log.info("⚠️ Skipped duplicate streamId: {}", streamId);
    }
}
```

When the program is running, you can inspect the __Pending Entries List__ using `XPENDING`:
```
XPENDING race:france race-group
1) (integer) 10                       # Total pending messages
2) "1754490516011-0"                  # Oldest pending ID
3) "1754490516011-9"                  # Newest pending ID
4) 1) 1) "consumer-B"
      2) "10"
```

You can manually acknowledge the first message:
```
127.0.0.1:6379> XACK race:france race-group 1754490516011-0
(integer) 1
```

Now the XPENDING shows 9 remaining:
```
127.0.0.1:6379> XPENDING race:france race-group
1) (integer) 19
2) "1754490516011-1"
3) "1754490516011-19"
4) 1) 1) "consumer-B"
      2) "19"
```

## ✅ Spring Data Redis – Implement Acknowledgement
Now let’s implement what was missing:
```java
@Scheduled(fixedDelay = 60000)
public void consumeStreamGroup() {
    StreamOperations<String, Object, Object> streamOps = redisTemplate.opsForStream();

    try {
       /*
        *   XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >
        */
        List<MapRecord<String, Object, Object>> records = streamOps.read(
                Consumer.from(GROUP_NAME, CONSUMER_NAME),
                StreamReadOptions.empty().block(Duration.ofSeconds(5)).count(10),
                StreamOffset.create(STREAM_KEY, ReadOffset.from("0"))
            );

        );

        if (records == null || records.isEmpty()) {
            log.debug("⏳ No new messages.");
            return;
        }

        for (MapRecord<String, Object, Object> record : records) {
            String streamId = record.getId().getValue();

            if (!repository.existsByStreamId(streamId)) {
                RaceStreamEntity entity = toEntity(record);
                repository.save(entity);

                // Acknowledge after successful save
                streamOps.acknowledge(STREAM_KEY, GROUP_NAME, record.getId());
                log.info("✅ Saved & ACK: {}", streamId);
            } else {
                log.info("⚠️ Skipped duplicate streamId: {}", streamId);
            }
        }
    } catch (DataAccessException e) {
        log.error("❌ Redis access error: {}", e.getMessage(), e);
    } catch (Exception e) {
        log.error("❌ Unknown error in stream consumption", e);
    }
}
```

## Testing It Step by Step
When you restart the application and let it process again, you’ll observe the number of pending messages __decrease progressively__:

```
127.0.0.1:6379> XPENDING race:france race-group
1) (integer) 49
2) "1754490516011-1"
3) "1754490516011-49"
4) 1) 1) "consumer-B"
      2) "49"

127.0.0.1:6379> XPENDING race:france race-group
1) (integer) 39
2) "1754490516011-11"
3) "1754490516011-49"
4) 1) 1) "consumer-B"
      2) "39"

127.0.0.1:6379> XPENDING race:france race-group
1) (integer) 29
2) "1754490516011-21"
3) "1754490516011-49"
4) 1) 1) "consumer-B"
      2) "29"

127.0.0.1:6379> XPENDING race:france race-group
1) (integer) 19
2) "1754490516011-31"
3) "1754490516011-49"
4) 1) 1) "consumer-B"
      2) "19"    

127.0.0.1:6379> XPENDING race:france race-group
1) (integer) 9
2) "1754490516011-41"
3) "1754490516011-49"
4) 1) 1) "consumer-B"
      2) "9"      

127.0.0.1:6379> XPENDING race:france race-group
1) (integer) 0
2) (nil)
3) (nil)
4) (nil)              
```
This confirms that your consumer is successfully acknowledging each message after processing.


## Key Takeaways
* In this section, we extended our stream consumer to handle acknowledgement via XACK, completing the message lifecycle.
* Instead of consuming only unseen entries (>) like before, we now also retrieve __pending unacknowledged messages__ for retry:
    ```
    StreamOffset.create(STREAM_KEY, ReadOffset.from("0"))
    ```
* Then, after successfully persisting to the database, we acknowledge each processed message:
    ```
    streamOps.acknowledge(STREAM_KEY, GROUP_NAME, record.getId());
    ```
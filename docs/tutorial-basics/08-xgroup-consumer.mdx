---
sidebar_position: 8
---

# XGROUP ...
In this section, we'll dive into the concept of **Consumers** and **Groups** in Redis Streams. The term _"consumer"_ only matters **within a consumer group** context.


## Redis CLI
As usual, we’ll use Redis CLI to test and understand how to work with groups and consumers before applying it in Spring Data Redis.


## Create Group (Mandatory)
Before using consumer groups, you **must create a group**. This is a **one-time setup**.
```
XGROUP CREATE race:france race-group 0 MKSTREAM
```
What it does?
* Creates a consumer group named race-group ***(can be any name)***
* Associated with stream **race:france**
* Starting from ID 0 (i.e., from the beginning)
    * `0` Start from the beginning of the stream (include all existing messages)
    * `$` Start from the latest message (only process new messages added after the group is created)
    * `<specific-id>` Start from a specific stream ID like 1692900280032-0
* If stream doesn’t exist yet, __MKSTREAM__ will create it

## Consumer Creation (Optional)
Think of it as: "Hey Redis, just letting you know consumer-B exists." (But it's not doing anything yet.)
```
XGROUP CREATECONSUMER race:france race-group consumer-B
```
* Creates a new consumer named __consumer-B__
* Registers it under group race-group for stream race:france
* Does NOT start reading any messages
* Used mainly for:
    * Pre-registering
    * Monitoring via `XINFO CONSUMERS`
* ⚠️ It will fail if the group doesn’t already exist.
    ```
    (error) NOGROUP No such consumer group 'race-group' for key name 'race:france'
    ```

## Consuming Messages
To actually start reading messages with a consumer:
```
XREADGROUP GROUP race-group consumer-B STREAMS race:france >
```
* Creates consumer-B if not already exists (a shorthand of `XGROUP CREATECONSUMER`)
* Starts consuming messages from race:france
* Uses group race-group to track delivery, pending and acknowledgments
* Will return unacknowledged messages previously sent to this consumer
* ⚠️ It will fail if the group doesn’t already exist.
    ```
    (error) NOGROUP No such consumer group 'race-group' for key name 'race:france'
    ```
* Redis Stream entry ID options for reading
    | Symbol.    |  Meaning              |
    | ---------- | --------------------- | 
    | `>`        |  Get **new messages** not yet delivered         |
    | `0`, `0-0` |  Return unacknowledged messages for this group from the start (use for retries) |
    | `<specific-id> `  | Start from only **new** messages going forward |


## Full example
```
# 1. Create stream & group
XGROUP CREATE race:france race-group 0 MKSTREAM

# 2. (Optional) Create consumer
XGROUP CREATECONSUMER race:france race-group consumer-B

# 3. Start consuming
XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >

# 4. Optionally: Acknowledge processed messages (Will be cover next)
XACK race:france race-group <message-id>
  
```

## Understanding Behavior of XGROUP CREATE ... 0 + >
1. You create a group `XGROUP CREATE race:france race-group 0 MKSTREAM`
2. Redis assumes this group has seen nothing yet — starting at ID 0.
3. When calling:
   ```
    XREADGROUP GROUP race-group consumer-B STREAMS race:france >
   ```
3. Redis interprets it as:
    * “Give me entries that have not yet been delivered to anyone in this group.”
5. So even if 50 messages were added earlier, they’re still undelivered → Redis returns them

##  Practice #1 – Using > to Fetch in Batches
Run this twice to observe batch consumption:
```
127.0.0.1:6379> XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >
1) 1) "race:france"
   2)  1) 1) "1754477775952-0"
          2) 1) "rider"
             2) "Moreira"
             3) "speed"
             4) "34.4"
             5) "position"
             6) "1"
             7) "location_id"
             8) "1"
       ....
      10) 1) "1754477775952-9"
          2) 1) "rider"
             2) "Pogacar"
             3) "speed"
             4) "30.3"
             5) "position"
             6) "10"
             7) "location_id"
             8) "3"
127.0.0.1:6379> XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >
1) 1) "race:france"
   2)  1) 1) "1754479265672-10"
          2) 1) "rider"
             2) "Fernandez"
             3) "speed"
             4) "29.6"
             5) "position"
             6) "11"
             7) "location_id"
             8) "1"
             ,,,   
      10) 1) "1754479265672-19"
          2) 1) "rider"
             2) "Lopez"
             3) "speed"
             4) "20.1"
             5) "position"
             6) "20"
             7) "location_id"
             8) "3"                       
```
| Call         | What Happens                     |
| ------------ | -------------------------------- |
| 1st          | Returns 10 unseen messages       |
| 2nd          | Returns next 10                  |
| ...          | Until all 50 are seen            |
| After all 50 | Returns nothing until new `XADD` |


## Practice #2 – Using 0 to Fetch Pending Messages
Fetch messages that were already delivered to this group but not yet acknowledged (in other words, pending messages)
```
127.0.0.1:6379> XREADGROUP GROUP race-group consumer-B STREAMS race:france 0
1) 1) "race:france"
   2)  1) 1) "1754477775952-0"
          2) 1) "rider"
             2) "Moreira"
             3) "speed"
             4) "34.4"
             5) "position"
             6) "1"
             7) "location_id"
             8) "1"
      ..... 
      20) 1) "1754477775952-19"
          2) 1) "rider"
             2) "Vingegaard"
             3) "speed"
             4) "22.2"
             5) "position"
             6) "20"
             7) "location_id"
             8) "1"
```
#### What it means?
* Give me messages that were previously delivered to consumer-B but not yet acknowledged (aka: pending)
    * In ourcase return 20 records that had been consumed.
* However, if Redis returns empty array, so:
    * consumer-B has not received any messages yet   
    ```
    1) 1) "race:france"
       2) (empty array)
    ```

## Confirm with XPENDING
```
XPENDING race:france race-group

1) (integer) 20                       ← Total **pending** (unacknowledged) messages
2) "1754477775952-0"                  ← The smallest pending message ID
3) "1754477775952-19"                 ← The largest pending message ID
4) 1) 1) "consumer-B"                 ← The only consumer with pending messages
      2) "20"                         ← Count of pending messages for consumer-B
```
* consumer-B has 20 pending messages → ✅ means Redis has delivered 20 messages to it.
* The IDs range from `1754477775952-0` to `1754477775952-19`
* Those entries are still unacknowledged (you haven’t called XACK).


## Adding More Consumers
Let’s create consumer-C to process more:
```
# 1. (Optional) Create consumer
> XGROUP CREATECONSUMER race:france race-group consumer-C

# 2 Start consuming
> XREADGROUP GROUP race-group consumer-C STREAMS race:france >

# 3 Inspect the result
> XPENDING race:france race-group
1) (integer) 50
2) "1754477775952-0"
3) "1754477775952-49"
4) 1) 1) "consumer-B"
      2) "20"
   2) 1) "consumer-C"
      2) "30"
```
✅ All 50 messages were distributed but still unacknowledged.


## Spring Data Redis Integration

:::warning[Important]
In each of the examples, I use `FLUSHDB` to ensure the database starts clean. __Be careful__: if you have an existing Redis instance running on your local machine, `FLUSHDB` will __delete all data in the current database__.

If you're unsure or want to avoid losing important data, the safer approach is to __delete only the specific key__:

```bash
redis-cli DEL race:france
redis-cli --eval generate_race.lua race:france , 50
```
:::


Create spring boot project with following commands, this time we'll use h2 and Spring data JPA as well to process the data.
```
spring init -d=web,data-redis,data-jpa,h2,devtools,thymeleaf,lombok \
  -g com.example \
  -a demo \
  -p jar \
  --build maven \
  xgroup -x
```

add the following to application.yaml
```
spring:
  data:
    redis:
      host: localhost
      port: 6379
  h2:
    console:
      enabled: true
      path: /h2-console
  datasource:
    name: example
    username: sa
    password:
    generate-unique-name: false
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
  sql:
    init:
      mode: never
  jpa:
    open-in-view: false
    show-sql: true
    generate-ddl: true
    properties:
      hibernate:
        jdbc:
          lob:
            non_contextual_creation: true
        format_sql: true
        generate_statistics: true
    hibernate:
      ddl-auto: create-drop

logging:
  level:
    root: INFO
    org:
      springframework:
        security: TRACE
        web:
          reactive:
            function:
              client: DEBUG
      hibernate:
        SQL: DEBUG
        orm:
          jdbc:
            bind: TRACE
```

RaceStreamEntity.java
```
@Entity
@Table(name = "race_stream_entry")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RaceStreamEntity {

    @Id
    @GeneratedValue
    @UuidGenerator
    @Setter(AccessLevel.NONE)
    private UUID id;

    @Column(name = "stream_id", unique = true)
    private String streamId; // Redis Stream ID (e.g., 1754326272465-45)

    @Column(name = "rider")
    private String rider;

    @Column(name = "speed")
    private Double speed;

    @Column(name = "position")
    private Integer position;

    @Column(name = "location_id")
    private Integer locationId;

    @Column(name = "received_at")
    private LocalDateTime receivedAt;

}
```

RaceStreamRepository.java
```java

@Repository
public interface RaceStreamRepository extends JpaRepository<RaceStreamEntity, UUID>, JpaSpecificationExecutor<RaceStreamEntity> {

    boolean existsByStreamId(String streamId);
}
```

RaceStreamService.java
```
@Slf4j
@Service
@RequiredArgsConstructor
public class RaceStreamService {

    private final StringRedisTemplate redisTemplate;
    private final RaceStreamRepository repository;

    private static final String STREAM_KEY = "race:france";
    private static final String GROUP_NAME = "race-group";
    private static final String CONSUMER_NAME = "consumer-B";
    private final ExecutorService executor = Executors.newSingleThreadExecutor();

    @PostConstruct
    public void autoStartConsumer() {
        executor.submit(this::tailStream);
    }

    @PostConstruct
    public void init() {
        createGroupIfNotExists();
    }

    /*
     *   XGROUP CREATE race:france race-group 0 MKSTREAM
     */
    private void createGroupIfNotExists() {
        try {
            redisTemplate.opsForStream().createGroup(STREAM_KEY, ReadOffset.from("0"), GROUP_NAME);
            log.info("✅ Created group '{}' on stream '{}'", GROUP_NAME, STREAM_KEY);
        } catch (RedisSystemException e) {
            if (e.getCause() instanceof RedisBusyException) {
                log.info("ℹ️ Group '{}' already exists, skipping creation", GROUP_NAME);
            } else {
                throw e;
            }
        }
    }

    @Scheduled(fixedDelay = 60000) // every 60 seconds
    public void consumeStreamGroup() {
        StreamOperations<String, Object, Object> streamOps = redisTemplate.opsForStream();

        try {
            /*
             *   XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >
             */
            List<MapRecord<String, Object, Object>> records = streamOps.read(
                    Consumer.from(GROUP_NAME, CONSUMER_NAME),
                    StreamReadOptions.empty().block(Duration.ofSeconds(5)).count(10),
                    StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed())
            );

            if (records == null || records.isEmpty()) {
                log.debug("⏳ No new messages.");
                return;
            }

            for (MapRecord<String, Object, Object> record : records) {
                String streamId = record.getId().getValue();

                if (!repository.existsByStreamId(streamId)) {
                    RaceStreamEntity entity = toEntity(record);
                    repository.save(entity);

                    // @TODO: Acknowledge after successful save
                } else {
                    log.info("⚠️ Skipped duplicate streamId: {}", streamId);
                }
            }
        } catch (DataAccessException e) {
            log.error("❌ Redis access error: {}", e.getMessage(), e);
        } catch (Exception e) {
            log.error("❌ Unknown error in stream consumption", e);
        }
    }

    private RaceStreamEntity toEntity(MapRecord<String, Object, Object> record) {
        Map<Object, Object> valueMap = record.getValue();
        return RaceStreamEntity.builder()
                .streamId(record.getId().getValue())
                .rider(valueMap.getOrDefault("rider", "").toString())
                .speed(Double.parseDouble(valueMap.getOrDefault("speed", "0").toString()))
                .position(Integer.parseInt(valueMap.getOrDefault("position", "0").toString()))
                .locationId(Integer.parseInt(valueMap.getOrDefault("location_id", "0").toString()))
                .receivedAt(LocalDateTime.now())
                .build();
    }

    public void tailStream() {
        StreamOperations<String, Object, Object> streamOps = redisTemplate.opsForStream();
        String lastSeenId = "$"; // only new messages

        while (true) {
            try {
                List<MapRecord<String, Object, Object>> records = streamOps.read(
                        StreamReadOptions.empty().block(Duration.ofSeconds(10)).count(10),
                        StreamOffset.create(STREAM_KEY, ReadOffset.from(lastSeenId))
                );

                if (records == null || records.isEmpty()) {
                    continue; // wait again
                }

                for (MapRecord<String, Object, Object> record : records) {
                    String streamId = record.getId().getValue();

                    if (!repository.existsByStreamId(streamId)) {
                        RaceStreamEntity entry = toEntity(record);
                        repository.save(entry);
                    }

                    lastSeenId = streamId;
                }

            } catch (Exception ex) {
                ex.printStackTrace(); // log and continue
            }
        }
    }
}
```


from the DemoApplication.java
```java
@SpringBootApplication
@EnableScheduling
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}

}
```

## What the Spring Boot Program Is Doing
Spring Boot program is doing stream consumption from Redis and persisting stream entries into a database, with the following key steps:

__1. Creates the Consumer Group (Once at Startup)__
```java
@PostConstruct
public void init() {
    redisTemplate.opsForStream().createGroup(STREAM_KEY, ReadOffset.from("0"), GROUP_NAME);
}
```
* This is equivalent to:
    ```
    XGROUP CREATE race:france race-group 0 MKSTREAM
    ```
* It ensures the consumer group race-group is created for stream race:france.

__2. Schedules a Consumer Task (Every 60 Seconds)__
```java
@Scheduled(fixedDelay = 60000) // every 60s
public void consumeStreamGroup()
```
* This is your background stream processor.
* It runs every minute to read from the Redis stream using the consumer group model.

__3. Reads Undelivered Messages via XREADGROUP__
```java
streamOps.read(
    Consumer.from(GROUP_NAME, CONSUMER_NAME),
    StreamReadOptions.empty().block(Duration.ofSeconds(5)).count(10),
    StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed())
)
```
* Equivalent Redis CLI:
    ```
    XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >
    ```
* What it does:
    * Reads new messages (>) for consumer-B
    * Redis tracks what messages were delivered but not acknowledged


__4. Persists Each Entry to H2 Database__
```java
if (!repository.existsByStreamId(streamId)) {
    RaceStreamEntity entity = toEntity(record);
    repository.save(entity);
}
```
* Avoids duplicates by checking if streamId was already saved
* Maps Redis stream fields (e.g., rider, speed, etc.) to a JPA entity
* Stores them into your in-memory H2 table race_stream_entry

__5. No Interruption__

While the program is actively running—but before all previous messages have been processed—if you execute an __XADD__, the new message will still be picked up and persisted to the database without interruption.
```
XADD race:france * rider "Pogacar" speed 38.9 position 1 location_id 1
"1754485788977-0"
```
Unlike the @Scheduled polling approach (which may introduce delays), this tailing consumer loop continuously listens using BLOCK, allowing it to process newly added messages immediately, even while older entries are still being handled.
✅ The processing is seamless and non-blocking across messages, and no messages are skipped or lost (as long as each is uniquely stored by streamId).


## ❌ What’s Missing or Not Yet Implemented?
>> You haven’t acknowledged any message yet.

#### In Redis terms:
* Messages delivered to the consumer stay in the Pending Entries List (PEL) until you XACK them.
    ```
    if (!repository.existsByStreamId(streamId)) {
        RaceStreamEntity entity = toEntity(record);
        repository.save(entity);

        // ✅ Acknowledge this message after successful save
        streamOps.acknowledge(STREAM_KEY, GROUP_NAME, record.getId());
        log.info("✅ Acknowledged stream ID {}", streamId);
    }
    ```

* This means:
    * Redis thinks they are still "unprocessed" or "pending retry"
    * If the consumer crashes or restarts, Redis will not re-deliver these messages unless you recover them manually or auto-claim them (XAUTOCLAIM / XCLAIM)

* __Retry Logic for Failed Saves__
    * If you want reliability, you can implement retry mechanisms for failed DB writes, and only XACK after success.
    * Use XAUTOCLAIM to recover stuck messages
    * Add dead-letter queue if a message repeatedly fails
* __Gracefully shutdown:__
    ```
    @PreDestroy
    public void shutdown() {
        running = false;
        executor.shutdownNow(); // Optional: force shutdown if needed
        log.info("🔴 Stream consumer stopped.");
    }

    ```

## Best Pratices
In production systems, we typically avoid using @Scheduled for real-time stream consumption, especially when working with Redis Streams (or Kafka, RabbitMQ, etc.). Scheduled polling introduces latency, wasted CPU cycles, and potential inconsistencies when manually tracking offsets like the last seen record ID.

Instead, a production-grade Redis Stream consumer should be designed to:
* Start automatically when the application starts
* Run in a continuous background thread or task
* Use XREADGROUP with BLOCK to efficiently wait for new messages in an event-driven manner
* Use XACK after successful processing to let Redis handle delivery state

👉 This approach simulates the ideal pattern for overcoming previous issues with XREAD, where developers had to manually track and persist the last seen ID (e.g. via $, specific stream ID, or 0-0).
By using XREADGROUP with BLOCK, Redis remembers what messages have or haven’t been delivered to each consumer group, and automatically resumes from the correct position — eliminating the need to self-manage offset tracking.
The thread is only interrupted when new data arrives or during shutdown, ensuring high efficiency and reliability in stream processing.




### 1. Kick Off Consumer in @PostConstruct or @EventListener
Either of these works:
```java
@PostConstruct
public void startConsumerThread() { ... }

-- or --

@EventListener(ApplicationReadyEvent.class)
public void startConsumerThread() { ... }
```
### 2.  Use a Long-Running Background Thread
```
Executors.newSingleThreadExecutor().submit(() -> {
    while (true) {
        List<MapRecord<String, Object, Object>> records = redisTemplate.opsForStream().read(
            Consumer.from("race-group", "consumer-B"),
            StreamReadOptions.empty().block(Duration.ofSeconds(30)).count(10),
            StreamOffset.create("race:france", ReadOffset.lastConsumed())
        );

        for (MapRecord<String, Object, Object> record : records) {
            // process and XACK
        }
    }
});
```
Example:
```java
@Slf4j
@Component
@RequiredArgsConstructor
public class RaceStreamConsumer {

    private final StringRedisTemplate redisTemplate;
    private final RaceStreamRepository repository;

    private final ExecutorService executor = Executors.newSingleThreadExecutor();
    private volatile boolean running = true;

    private static final String STREAM_KEY = "race:france";
    private static final String GROUP_NAME = "race-group";
    private static final String CONSUMER_NAME = "consumer-B";

    @PostConstruct
    public void init() {
        createGroupIfNotExists();
    }

    /*
     *   XGROUP CREATE race:france race-group 0 MKSTREAM
     */
    private void createGroupIfNotExists() {
        try {
            redisTemplate.opsForStream().createGroup(STREAM_KEY, ReadOffset.from("0"), GROUP_NAME);
            log.info("✅ Created group '{}' on stream '{}'", GROUP_NAME, STREAM_KEY);
        } catch (RedisSystemException e) {
            if (e.getCause() instanceof RedisBusyException) {
                log.info("ℹ️ Group '{}' already exists, skipping creation", GROUP_NAME);
            } else {
                throw e;
            }
        }
    }

    @EventListener(ApplicationReadyEvent.class)
    public void startConsumerThread() {
        executor.submit(() -> {
            while (running) {
                try {
                    List<MapRecord<String, Object, Object>> records = redisTemplate.opsForStream().read(
                            Consumer.from(GROUP_NAME, CONSUMER_NAME),
                            StreamReadOptions.empty().block(Duration.ofSeconds(30)).count(10),
                            StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed())
                    );

                    if (records == null || records.isEmpty()) {
                        continue; // Wait again
                    }

                    for (MapRecord<String, Object, Object> record : records) {
                        String streamId = record.getId().getValue();

                        if (!repository.existsByStreamId(streamId)) {
                            repository.save(toEntity(record));
                            redisTemplate.opsForStream().acknowledge(STREAM_KEY, GROUP_NAME, record.getId());
                        }
                    }
                } catch (Exception e) {
                    log.error("Stream processing error", e);

                    try {
                        Thread.sleep(1000); // Optional backoff
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }

            log.info("🛑 Redis Stream consumer has stopped.");
        });
    }

    @PreDestroy
    public void shutdownConsumer() {
        running = false;
        executor.shutdownNow(); // Optional: force interrupt
        log.info("🔴 Graceful shutdown triggered for Redis consumer.");
    }

    private RaceStreamEntity toEntity(MapRecord<String, Object, Object> record) {
        Map<Object, Object> m = record.getValue();

        return RaceStreamEntity.builder()
                .streamId(record.getId().getValue())
                .rider(String.valueOf(m.get("rider")))
                .speed(Double.valueOf(String.valueOf(m.get("speed"))))
                .position(Integer.valueOf(String.valueOf(m.get("position"))))
                .locationId(Integer.valueOf(String.valueOf(m.get("location_id"))))
                .receivedAt(LocalDateTime.now())
                .build();
    }
}
```

## Additional Information on BLOCK
Redis is single-threaded for command execution, but your Java program is not — and BLOCK 0 (or BLOCK N) doesn't block Redis itself; it only blocks the client connection (your thread), not the server.

#### Key Understanding: Who Is Blocking Whom?
* `BLOCK` blocks the client-side connection, not Redis.
* When you call:
    ```
    XREAD BLOCK 0 STREAMS race:france >
    ```
    * Redis does not block its own execution
    * It just holds that one client connection open, waiting for new data
    * Other clients (your app, other services) can still run commands freely
* `BLOCK` is not a sleep, it is a timeout
    * “Wait up to 30 seconds for a message to arrive.
    * If a message comes in earlier, return immediately.
    * If nothing arrives within 30 seconds, return null.”
    * ⛔ It does not idle or sleep for 30 seconds after returning.
    * ✅ It just returns immediately, and your code continues executing.

### Timeline Visualization
| Time (s) | Event                                                   |
| -------- | ------------------------------------------------------- |
| 0        | You call `.read(BLOCK 30)`                              |
| 30       | No message — Redis returns `null`                       |
| 30–35    | Your code loops again, calls `.read(BLOCK 30)` again    |
| 35       | Message arrives                                         |
| 35–36    | Redis immediately returns the message to the new read() |
| 36+      | Your code processes the message                         |


#### Analogy
Imagine Redis as a waiter:
* You (client A) say: "Wait at my table until food is ready." (BLOCK)
* The waiter just keeps your request on hold
* Meanwhile, the waiter continues to serve other tables (clients)
* When food (message) is ready, the waiter replies to you
* So Redis is not blocked. Just your request is suspended until fulfilled.

### In Java Terms
```
List<MapRecord<...>> records = streamOps.read(... BLOCK 0 ...);
```
* This blocks only that Java thread (e.g. inside your Runnable / Executor)
* Redis is totally fine — other operations like XADD, XINFO, or even other consumers continue running
* Your app can run hundreds of threads, each with their own BLOCK calls, if needed
* You Can Safely Use BLOCK 0 in Production
* The only __drawback__ is graceful shutdown more difficult — not impossible, but you’ll need extra work to support it.


```
List<MapRecord<...>> records = streamOps.read(... BLOCK 5 or 10 ...);
```
* Fast enough for near real-time
* Easy to exit on shutdown (running flag)
* You don’t need ultra-low latency (sub-second responsiveness)
* Your thread will resume and do a null check every 5s or 10s depends what you set it
* Slight increase in Redis commands, Redis receives a command every 30s per consumer
* Slight latency on arrival. If a message arrives at second 0.1, your code may not see it until second 30 (worst case)

## Summary

| Use Case                         | Create consumer? | Use `XREADGROUP`? | Use `XREAD`? |
| -------------------------------- | ---------------- | ----------------- | ------------ |
| Single user reads stream         | ❌ No             | ❌ No              | ✅ Yes        |
| Multiple consumers (shared work) | ✅ Yes            | ✅ Yes             | ❌ No         |
| Need retries, reliability        | ✅ Yes            | ✅ Yes             | ❌ No         |


Redis tracks:
* Each consumer (e.g., consumer-1, consumer-2)
* Which message was delivered to which consumer
* Which messages are pending acknowledgment
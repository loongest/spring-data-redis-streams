"use strict";(self.webpackChunkredis=self.webpackChunkredis||[]).push([[1864],{1316:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"tutorial-basics/xpending","title":"XPENDING","description":"The XPENDING command shows information about pending entries in a stream for a given consumer group.","source":"@site/docs/tutorial-basics/12-xpending.mdx","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/xpending","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xpending","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/12-xpending.mdx","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"sidebar_position":12},"sidebar":"tutorialSidebar","previous":{"title":"XINFO CONSUMERS","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xinfo-consumers"},"next":{"title":"Maintenance with XTRIM","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xtrim"}}');var r=s(4848),t=s(8453);const o={sidebar_position:12},a="XPENDING",d={},c=[{value:"Syntax",id:"syntax",level:2},{value:"Basic usage \u2013 check if there are pending messages",id:"basic-usage--check-if-there-are-pending-messages",level:2},{value:"Extended usage \u2013 see idle time and delivery count",id:"extended-usage--see-idle-time-and-delivery-count",level:2},{value:"Example: Finding long-idle messages for a specific consumer",id:"example-finding-long-idle-messages-for-a-specific-consumer",level:2},{value:"When to use XPENDING",id:"when-to-use-xpending",level:2}];function l(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"xpending",children:"XPENDING"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"XPENDING"})," command shows information about ",(0,r.jsx)(n.strong,{children:"pending entries"})," in a stream ",(0,r.jsx)(n.strong,{children:"for a given consumer group"}),".",(0,r.jsx)(n.br,{}),"\n","A pending entry is a message that was delivered to a consumer but has not yet been acknowledged with ",(0,r.jsx)(n.code,{children:"XACK"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"XPENDING key group [[IDLE min-idle-time] start end count [consumer]]\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"key"}),": The name of the stream."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"group"}),": The name of the consumer group."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"IDLE min-idle-time"}),": (Optional) Filters messages that have been idle for at least min-idle-time milliseconds."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"start"}),": The starting stream ID for the range. - is a special value representing the smallest possible ID."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"end"}),": The ending stream ID for the range. + is a special value representing the largest possible ID."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"count"}),": The maximum number of messages to return."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"consumer"}),": (Optional) Returns only the pending messages for a specific consumer."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-usage--check-if-there-are-pending-messages",children:"Basic usage \u2013 check if there are pending messages"}),"\n",(0,r.jsxs)(n.p,{children:["In the simplest form, you can use ",(0,r.jsx)(n.code,{children:"XPENDING"})," to check whether there are any unacknowledged messages in the group:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"XPENDING race:france race-group\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'1) (integer) 20                       \u2190 Total pending (unacknowledged) messages\n2) "1754477775952-0"                  \u2190 Oldest pending message ID\n3) "1754477775952-19"                 \u2190 Newest pending message ID\n4) 1) 1) "consumer-B"                 \u2190 Consumer name\n      2) "20"                         \u2190 Number of pending messages for this consumer\n'})}),"\n",(0,r.jsx)(n.p,{children:"This tells us that consumer-B has 20 messages that were delivered but not yet acknowledged."}),"\n",(0,r.jsx)(n.h2,{id:"extended-usage--see-idle-time-and-delivery-count",children:"Extended usage \u2013 see idle time and delivery count"}),"\n",(0,r.jsx)(n.p,{children:"If you want to know how long each message has been pending and how many times it has been delivered, use the extended form:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'XPENDING race:france race-group - + 10\n1) 1) "1754477775952-0"        \u2190 Message ID\n   2) "consumer-B"             \u2190 Consumer name\n   3) (integer) 103170         \u2190 Idle time in ms (~103 seconds since last delivery)\n   4) (integer) 1              \u2190 Delivery count\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Here:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Idle time"})," = how long the message has been pending without being acknowledged"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Delivery count"})," = how many times Redis has delivered this message to consumers"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-finding-long-idle-messages-for-a-specific-consumer",children:"Example: Finding long-idle messages for a specific consumer"}),"\n",(0,r.jsx)(n.p,{children:'You can combine the filters to find messages that have been idle for a long time for a specific consumer. This is useful for targeting potentially "stuck" jobs.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"# Find up to 10 messages for 'consumer-B' that have been idle for at least 60 seconds (60000 ms)\nXPENDING race:france race-group IDLE 60000 - + 10 consumer-B\n"})}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use-xpending",children:"When to use XPENDING"}),"\n",(0,r.jsxs)(n.p,{children:["From experience, there are two major reasons to use ",(0,r.jsx)(n.code,{children:"XPENDING"})," regularly:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recovery of unprocessed messages"}),"\nUse ",(0,r.jsx)(n.code,{children:"XPENDING"})," to check for stuck or abandoned messages. If found, you can recover them with ",(0,r.jsx)(n.code,{children:"XAUTOCLAIM"})," or ",(0,r.jsx)(n.code,{children:"XCLAIM"})," so another consumer can process them."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Safe housekeeping before trimming"}),"\nRedis Streams are append-only logs. If your application relies heavily on them, streams can grow very large over time.\nYou can use ",(0,r.jsx)(n.code,{children:"XTRIM"})," to remove old entries and save memory, but ",(0,r.jsx)(n.strong,{children:"never trim blindly"})," \u2014 always check ",(0,r.jsx)(n.code,{children:"XPENDING"})," first to ensure you\u2019re not deleting unprocessed messages."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In the next topic, we\u2019ll cover how to combine XPENDING with XTRIM to safely manage stream size without losing unprocessed data."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);
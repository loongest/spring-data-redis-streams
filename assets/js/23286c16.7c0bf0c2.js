"use strict";(self.webpackChunkredis=self.webpackChunkredis||[]).push([[5736],{4806:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"tutorial-basics/xinfo-consumers","title":"XINFO CONSUMERS","description":"The XINFO CONSUMERS command returns the list of consumers that belong to a specific ` consumer group of the stream stored at `.","source":"@site/docs/tutorial-basics/11-xinfo-consumers.mdx","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/xinfo-consumers","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xinfo-consumers","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/11-xinfo-consumers.mdx","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"XCLAIM/XAUTOCLAIM","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xclaim"},"next":{"title":"XPENDING","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xpending"}}');var t=s(4848),i=s(8453);const o={sidebar_position:11},a="XINFO CONSUMERS",c={},d=[{value:"Why It Matters",id:"why-it-matters",level:2},{value:"Example: Dynamic Consumer Name via Hostname",id:"example-dynamic-consumer-name-via-hostname",level:4},{value:"Consumer Class with Injected Hostname",id:"consumer-class-with-injected-hostname",level:4},{value:"Verifying Consumer Status",id:"verifying-consumer-status",level:2},{value:"Why Messages May Not Be Consumed",id:"why-messages-may-not-be-consumed",level:2},{value:"Key Behavior to Understand",id:"key-behavior-to-understand",level:3},{value:"How to Handle Unacknowledged Messages",id:"how-to-handle-unacknowledged-messages",level:2},{value:"Recommended: Use XCLAIM (or Spring\u2019s .claim())",id:"recommended-use-xclaim-or-springs-claim",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"xinfo-consumers",children:"XINFO CONSUMERS"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"XINFO CONSUMERS"})," command returns the list of consumers that belong to a specific ",(0,t.jsx)(n.code,{children:"<groupname>"})," consumer group of the stream stored at ",(0,t.jsx)(n.code,{children:"<key>"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"XINFO CONSUMERS <key> <group>\n"})}),"\n",(0,t.jsx)(n.p,{children:"Sample output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'127.0.0.1:6379> XINFO CONSUMERS race:france race-group\n1) 1) "name"\n   2) "Chee-MacBook-Pro.local"\n   3) "pending"\n   4) (integer) 0\n   5) "idle"\n   6) (integer) 24639\n   7) "inactive"\n   8) (integer) 462956\n2) 1) "name"\n   2) "Chee-MacBook-Pro.local:recovery"\n   3) "pending"\n   4) (integer) 0\n   5) "idle"\n   6) (integer) 1387718\n   7) "inactive"\n   8) (integer) 1387718\n127.0.0.1:6379>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"why-it-matters",children:"Why It Matters"}),"\n",(0,t.jsx)(n.p,{children:"In real-world applications \u2014 especially in microservices \u2014 consumer names are often dynamically assigned, not hardcoded. For example, they may be based on the hostname or injected as a random string at deployment time (e.g., in Kubernetes or Docker)."}),"\n",(0,t.jsx)(n.h4,{id:"example-dynamic-consumer-name-via-hostname",children:"Example: Dynamic Consumer Name via Hostname"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"@Configuration\npublic class BeanConfig\n{\n    @Bean\n    public String hostname() throws UnknownHostException {\n        return InetAddress.getLocalHost().getHostName();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"consumer-class-with-injected-hostname",children:"Consumer Class with Injected Hostname"}),"\n",(0,t.jsx)(n.p,{children:"We modify our consumer to use the hostname as the consumer name:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'@Slf4j\n@Component\npublic class RaceStreamConsumer {\n\n    private final StringRedisTemplate redisTemplate;\n    private final RaceStreamRepository repository;\n    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n    private volatile boolean running = true;\n\n    private static final String STREAM_KEY = "race:france";\n    private static final String GROUP_NAME = "race-group";\n    // constructor injection\n    public RaceStreamConsumer(\n            StringRedisTemplate redisTemplate,\n            RaceStreamRepository repository,\n            @Qualifier("hostname") String consumerName\n    ) {\n        this.repository = repository;\n        this.redisTemplate = redisTemplate;\n        this.CONSUMER_NAME = consumerName;\n    }\n\n    ...\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"verifying-consumer-status",children:"Verifying Consumer Status"}),"\n",(0,t.jsx)(n.p,{children:"Once your application starts, and your consumer thread begins reading from the stream, you can check the stream contents with:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XRANGE race:france - +\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However, if your logs show no message processing activity, how can you be sure your consumer is properly registered? Use ",(0,t.jsx)(n.code,{children:"XINFO"})," This lets you confirm that the consumer was registered within the group."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XINFO CONSUMERS race:france race-group\n"})}),"\n",(0,t.jsx)(n.h2,{id:"why-messages-may-not-be-consumed",children:"Why Messages May Not Be Consumed"}),"\n",(0,t.jsx)(n.p,{children:"Even if the consumer is registered, it might not consume any messages. One common reason is how the stream is being read:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"List<MapRecord<String, Object, Object>> records = redisTemplate.opsForStream().read(\n    Consumer.from(GROUP_NAME, CONSUMER_NAME),\n    StreamReadOptions.empty().block(Duration.ofMinutes(1)).count(10),\n    StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed())\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is equivalent to :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XGROUP CREATE race:france race-group 0 MKSTREAM\nXREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-behavior-to-understand",children:"Key Behavior to Understand"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Messages in a Redis Stream are only delivered once per consumer"}),"\n",(0,t.jsxs)(n.li,{children:["Messages that are delivered but not acknowledged will remain in a ",(0,t.jsx)(n.strong,{children:"pending state"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)("mark",{children:"ReadOffset.lastConsumed() tells Redis to only deliver new messages, not the ones already pending or acknowledged."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Message ID"}),(0,t.jsx)(n.th,{children:"Delivered to Consumer"}),(0,t.jsx)(n.th,{children:"Acknowledged?"}),(0,t.jsx)(n.th,{children:"Will it be redelivered?"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"1754564693298-0"})}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"\u274c No"}),(0,t.jsx)(n.td,{children:"\u274c Not automatically \u2014 needs manual recovery"})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"how-to-handle-unacknowledged-messages",children:"How to Handle Unacknowledged Messages"}),"\n",(0,t.jsx)(n.p,{children:"If you want to temporarily reprocess unacknowledged messages:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'StreamOffset.create(STREAM_KEY, ReadOffset.from("0"))\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u26a0\ufe0f But this approach is risky \u2014 multiple consumers doing this may result in duplicate processing."}),"\n",(0,t.jsx)(n.h2,{id:"recommended-use-xclaim-or-springs-claim",children:"Recommended: Use XCLAIM (or Spring\u2019s .claim())"}),"\n",(0,t.jsx)(n.p,{children:"Instead of rewinding to 0, the preferred production-safe way is to recover unacknowledged messages via XCLAIM."}),"\n",(0,t.jsx)(n.p,{children:"We\u2019ve shown how to implement this previously using Spring\u2019s claim() method inside a scheduled job."}),"\n",(0,t.jsx)(n.p,{children:"If you're interested in a full tutorial for XCLAIM/XAUTOCLAIM, refer to the Redis Stream Recovery Guide."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var r=s(6540);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);
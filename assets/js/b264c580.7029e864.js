"use strict";(self.webpackChunkredis=self.webpackChunkredis||[]).push([[193],{5763:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"tutorial-basics/best-practice","title":"Redis Stream Consumer Boilerplate","description":"After a few projects I\u2019ve settled on a code idiom that improves development time and covers the most common requirements:","source":"@site/docs/tutorial-basics/14-best-practice.mdx","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/best-practice","permalink":"/spring-data-redis-streams/docs/tutorial-basics/best-practice","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/14-best-practice.mdx","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"sidebar_position":14,"title":"Redis Stream Consumer Boilerplate"},"sidebar":"tutorialSidebar","previous":{"title":"Maintenance with XTRIM","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xtrim"}}');var s=r(4848),a=r(8453);const i={sidebar_position:14,title:"Redis Stream Consumer Boilerplate"},o="Redis Stream Consumer Boilerplate",c={},l=[{value:"Step 1: Abstract base class",id:"step-1-abstract-base-class",level:2},{value:"MapStruct",id:"mapstruct",level:2},{value:"Consumer class",id:"consumer-class",level:2},{value:"Stuck message recovery",id:"stuck-message-recovery",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"redis-stream-consumer-boilerplate",children:"Redis Stream Consumer Boilerplate"})}),"\n",(0,s.jsx)(n.p,{children:"After a few projects I\u2019ve settled on a code idiom that improves development time and covers the most common requirements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always listen for new messages from a Redis Stream."}),"\n",(0,s.jsx)(n.li,{children:"Always reclaim \u201cstuck\u201d messages that sit in the pending list too long."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["\ud83d\udca1"," Tip:"]})," if your app uses scheduled recovery, don\u2019t forget ",(0,s.jsx)(n.code,{children:"@EnableScheduling"})," on your Spring Boot application class."]}),"\n",(0,s.jsx)(n.h2,{id:"step-1-abstract-base-class",children:"Step 1: Abstract base class"}),"\n",(0,s.jsx)(n.p,{children:"Create an abstract base class to hold common behaviour:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Initialise the Redis consumer group"}),"\n",(0,s.jsxs)(n.li,{children:["Register the main consumer loop with ",(0,s.jsx)(n.code,{children:"@EventListener(ApplicationReadyEvent.class)"})]}),"\n",(0,s.jsx)(n.li,{children:"Add a shutdown hook for a clean stop"}),"\n",(0,s.jsxs)(n.li,{children:["Expose abstract ",(0,s.jsx)(n.code,{children:"map()"})," and ",(0,s.jsx)(n.code,{children:"handle()"})," so concrete consumers focus only on business logic"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Slf4j\npublic abstract class AbstractBaseConsumer<T> {\n\n    protected final StringRedisTemplate redisTemplate;\n    protected final String streamKey;\n    protected final String groupName;\n    protected final String consumerName;\n    private volatile boolean running = true;\n\n    protected final ExecutorService executor = new ThreadPoolExecutor(\n        2, 4, 60, TimeUnit.SECONDS,\n        new LinkedBlockingQueue<>(100),\n        new ThreadPoolExecutor.AbortPolicy()\n    );\n\n    protected AbstractBaseConsumer(StringRedisTemplate redisTemplate,\n                                   String streamKey,\n                                   String groupName,\n                                   String consumerName) {\n        this.redisTemplate = redisTemplate;\n        this.streamKey = streamKey;\n        this.groupName = groupName;\n        this.consumerName = consumerName;\n    }\n\n    @PostConstruct\n    public void initGroup() {\n        try {\n            redisTemplate.opsForStream().createGroup(streamKey, ReadOffset.from("0"), groupName);\n            log.info("Created group \'{}\' on stream \'{}\'", groupName, streamKey);\n        } catch (RedisSystemException e) {\n            if (e.getCause() instanceof io.lettuce.core.RedisBusyException) {\n                log.info("Group \'{}\' already exists", groupName);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        running = false;\n        executor.shutdownNow();\n    }\n\n    @EventListener(ApplicationReadyEvent.class)\n    public void start() {\n        executor.submit(this::loop);\n    }\n\n    private void loop() {\n        while (running) {\n            try {\n                List<MapRecord<String,Object,Object>> records = redisTemplate.opsForStream().read(\n                    Consumer.from(groupName, consumerName),\n                    StreamReadOptions.empty().block(Duration.ofMinutes(1)).count(10),\n                    StreamOffset.create(streamKey, ReadOffset.lastConsumed())\n                );\n\n                if (records == null || records.isEmpty()) continue;\n\n                processBatch(records);\n            } catch (Exception e) {\n                log.error("Stream processing error", e);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        }\n        log.info("Consumer {} stopped.", consumerName);\n    }\n\n    protected void processBatch(List<MapRecord<String,Object,Object>> records) {\n        for (var record : records) {\n            try {\n                T payload = map(record.getValue());\n                handle(payload);\n                ack(record);\n            } catch (Exception e) {\n                onError(record.getId().getValue(), record, e);\n            }\n        }\n    }\n\n    protected void ack(MapRecord<String,Object,Object> record) {\n        redisTemplate.opsForStream().acknowledge(streamKey, groupName, record.getId());\n    }\n\n    protected void onError(String streamId, MapRecord<String,Object,Object> record, Exception e) {\n        log.error("Processing failed for streamId: {}", streamId, e);\n        // Optionally: publish to DLQ + ack on mapping/validation errors\n    }\n\n    protected abstract T map(Map<Object, Object> fields);\n    protected abstract void handle(T payload) throws Exception;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"mapstruct",children:"MapStruct"}),"\n",(0,s.jsx)(n.p,{children:"For payload mapping, use MapStruct to convert the Redis map into a Java class."}),"\n",(0,s.jsx)(n.p,{children:"Eg: Given this payload model:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class RaceData {\n    private String rider;\n    private String speed;\n    private String position;\n    private String locationId;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Create a mapper"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'import org.mapstruct.Mapper;\nimport org.mapstruct.Mapping;\nimport org.mapstruct.NullValueCheckStrategy;\nimport org.mapstruct.ReportingPolicy;\n\nimport java.util.Map;\n\n@Mapper(\n    componentModel = "spring",\n    nullValueCheckStrategy = NullValueCheckStrategy.ALWAYS,\n    unmappedTargetPolicy = ReportingPolicy.IFNORE\n)\npublic interface RaceDataMapper {\n\n    @Mapping(target = "rider",     expression = "java(asString(map.get(\\"rider\\")))")\n    @Mapping(target = "speed",     expression = "java(asString(map.get(\\"speed\\")))")\n    @Mapping(target = "position",  expression = "java(asString(map.get(\\"position\\")))")\n    @Mapping(target = "locationId",expression = "java(asString(map.get(\\"location_id\\")))")\n    RaceData fromMap(Map<Object, Object> map);\n\n    default String asString(Object v) {\n        return v == null ? null : String.valueOf(v).trim();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"consumer-class",children:"Consumer class"}),"\n",(0,s.jsxs)(n.p,{children:["A concrete consumer wires in the business service and the mapper, and implements ",(0,s.jsx)(n.strong,{children:"map()/handle()."})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'\n@Slf4j\n@Component\npublic class RaceFranceConsumer extends AbstractBaseConsumer<RaceData> {\n\n    private final YourBusinessService service;\n    private final RaceDataMapper mapper;\n\n    public RaceFranceConsumer(StringRedisTemplate redisTemplate,\n                              YourBusinessService service,\n                              RaceDataMapper mapper,\n                              @Qualifier("hostname") String consumerName) {\n        super(redisTemplate,\n              RedisEventTypes.RACE_STREAM_KEY,\n              RedisEventTypes.RACE_GROUP_NAME,\n              consumerName);\n        this.service = service;\n        this.mapper = mapper;\n    }\n\n    @Override\n    protected RaceData map(Map<Object,Object> fields) {\n        return mapper.fromMap(fields);\n    }\n\n    @Override\n    protected void handle(RaceData payload) throws Exception {\n        service.process(payload);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"stuck-message-recovery",children:"Stuck message recovery"}),"\n",(0,s.jsx)(n.p,{children:"Recovery consumers also extend the base class, and add a @Scheduled task to reclaim idle messages."}),"\n",(0,s.jsx)(n.p,{children:"(Keep the idle timeout longer than your worst-case processing time unless you also implement heartbeats.)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Slf4j\n@Component\npublic class RaceFranceRecovery extends AbstractBaseConsumer<RaceData> {\n\n    private final YourBusinessService service;\n    private final RaceDataMapper mapper;\n    private final String CONSUMER_NAME;\n\n    @Value("${stream.idle-timeout-minutes:15}")\n    private long idleTimeoutMinutes;\n\n    public RaceFranceRecovery(YourBusinessService service,\n                              RaceDataMapper mapper,\n                              StringRedisTemplate redisTemplate,\n                              @Qualifier("hostname") String consumerName) {\n        super(redisTemplate,\n              RedisEventTypes.RACE_STREAM_KEY,\n              RedisEventTypes.RACE_GROUP_NAME,\n              consumerName + ":recovery");\n        this.service = service;\n        this.mapper = mapper;\n        this.CONSUMER_NAME = consumerName;\n    }\n\n    @Override\n    public void start() {\n        // do nothing \u2014 prevents loop\n    }\n\n    @Override\n    protected RaceData map(Map<Object,Object> fields) {\n        return mapper.fromMap(fields);\n    }\n\n    @Override\n    protected void handle(RaceData payload) throws Exception {\n        service.process(payload);\n    }\n\n    @Scheduled(fixedRate = 600_000) // Depends your business logic\n    public void reclaimStuckMessages() {\n        log.info("\u2699\ufe0f Running job to reclaim stuck messages...");\n        try {\n            PendingMessagesSummary summary = redisTemplate.opsForStream()\n                .pending(RedisEventTypes.RACE_STREAM_KEY, RedisEventTypes.RACE_GROUP_NAME);\n\n            if (summary == null || summary.getTotalPendingMessages() == 0) return;\n\n            log.info("\u2139\ufe0f Found {} total pending messages. Checking for idle ones...",\n                     summary.getTotalPendingMessages());\n\n            PendingMessages pending = redisTemplate.opsForStream().pending(\n                RedisEventTypes.RACE_STREAM_KEY,\n                RedisEventTypes.RACE_GROUP_NAME,\n                Range.unbounded(),\n                100L\n            );\n\n            for (PendingMessage pm : pending) {\n                if (pm.getElapsedTimeSinceLastDelivery()\n                      .compareTo(Duration.ofMinutes(idleTimeoutMinutes)) > 0) {\n                    log.warn("\ud83d\udea8 Message {} by \'{}\' idle for {} \u2192 reclaiming",\n                             pm.getId(), pm.getConsumerName(), pm.getElapsedTimeSinceLastDelivery());\n\n                    List<MapRecord<String, Object, Object>> claimed = redisTemplate.opsForStream().claim(\n                        RedisEventTypes.RACE_STREAM_KEY,\n                        RedisEventTypes.RACE_GROUP_NAME,\n                        CONSUMER_NAME + ":recovery",\n                        Duration.ofSeconds(30),\n                        pm.getId()\n                    );\n\n                    if (!claimed.isEmpty()) {\n                        executor.submit(() -> processBatch(claimed));\n                    }\n                }\n            }\n        } catch (DataAccessException e) {\n            log.error("Redis access error during message reclamation: {}", e.getMessage(), e);\n        } catch (Exception e) {\n            log.error("Unexpected error during message reclamation", e);\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Optional but recommended"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"DLQ + ACK for poison messages (mapping/validation errors) so they don\u2019t loop forever."}),"\n",(0,s.jsx)(n.li,{children:"Max retry budget: after N deliveries (from XPENDING), move to DLQ and XACK."}),"\n",(0,s.jsx)(n.li,{children:"XAUTOCLAIM instead of XCLAIM for batch reclaiming of idle messages."}),"\n",(0,s.jsx)(n.li,{children:"Heartbeat to avoid reclaiming messages that are long-running but healthy."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"With this pattern the boilerplate lives in the base class, consumers and recovery jobs stay lean, and you can focus entirely on business logic."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);
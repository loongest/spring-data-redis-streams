"use strict";(self.webpackChunkredis=self.webpackChunkredis||[]).push([[2257],{1943:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"tutorial-basics/xgroup-consumer","title":"XGROUP ...","description":"In this section, we\'ll dive into the concept of Consumers and Groups in Redis Streams. The term \\"consumer\\" only matters within a consumer group context.","source":"@site/docs/tutorial-basics/08-xgroup-consumer.mdx","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/xgroup-consumer","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xgroup-consumer","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/08-xgroup-consumer.mdx","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"XREAD","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xread"},"next":{"title":"XACK","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xack"}}');var i=r(4848),t=r(8453);const a={sidebar_position:8},o="XGROUP ...",c={},d=[{value:"Redis CLI",id:"redis-cli",level:2},{value:"Create Group (Mandatory)",id:"create-group-mandatory",level:2},{value:"Consumer Creation (Optional)",id:"consumer-creation-optional",level:2},{value:"Consuming Messages",id:"consuming-messages",level:2},{value:"Full example",id:"full-example",level:2},{value:"Understanding Behavior of XGROUP CREATE ... 0 + &gt;",id:"understanding-behavior-of-xgroup-create--0--",level:2},{value:"Practice #1 \u2013 Using &gt; to Fetch in Batches",id:"practice-1--using--to-fetch-in-batches",level:2},{value:"Practice #2 \u2013 Using 0 to Fetch Pending Messages",id:"practice-2--using-0-to-fetch-pending-messages",level:2},{value:"What it means?",id:"what-it-means",level:4},{value:"Confirm with XPENDING",id:"confirm-with-xpending",level:2},{value:"Adding More Consumers",id:"adding-more-consumers",level:2},{value:"Spring Data Redis Integration",id:"spring-data-redis-integration",level:2},{value:"What the Spring Boot Program Is Doing",id:"what-the-spring-boot-program-is-doing",level:2},{value:"\u274c What\u2019s Missing or Not Yet Implemented?",id:"-whats-missing-or-not-yet-implemented",level:2},{value:"In Redis terms:",id:"in-redis-terms",level:4},{value:"Best Pratices",id:"best-pratices",level:2},{value:"1. Kick Off Consumer in @PostConstruct or @EventListener",id:"1-kick-off-consumer-in-postconstruct-or-eventlistener",level:3},{value:"2.  Use a Long-Running Background Thread",id:"2--use-a-long-running-background-thread",level:3},{value:"Additional Information on BLOCK",id:"additional-information-on-block",level:2},{value:"Key Understanding: Who Is Blocking Whom?",id:"key-understanding-who-is-blocking-whom",level:4},{value:"Timeline Visualization",id:"timeline-visualization",level:3},{value:"Analogy",id:"analogy",level:4},{value:"In Java Terms",id:"in-java-terms",level:3},{value:"Summary",id:"summary",level:2}];function l(e){const n={admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"xgroup-",children:"XGROUP ..."})}),"\n",(0,i.jsxs)(n.p,{children:["In this section, we'll dive into the concept of ",(0,i.jsx)(n.strong,{children:"Consumers"})," and ",(0,i.jsx)(n.strong,{children:"Groups"})," in Redis Streams. The term ",(0,i.jsx)(n.em,{children:'"consumer"'})," only matters ",(0,i.jsx)(n.strong,{children:"within a consumer group"})," context."]}),"\n",(0,i.jsx)(n.h2,{id:"redis-cli",children:"Redis CLI"}),"\n",(0,i.jsx)(n.p,{children:"As usual, we\u2019ll use Redis CLI to test and understand how to work with groups and consumers before applying it in Spring Data Redis."}),"\n",(0,i.jsx)(n.h2,{id:"create-group-mandatory",children:"Create Group (Mandatory)"}),"\n",(0,i.jsxs)(n.p,{children:["Before using consumer groups, you ",(0,i.jsx)(n.strong,{children:"must create a group"}),". This is a ",(0,i.jsx)(n.strong,{children:"one-time setup"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"XGROUP CREATE race:france race-group 0 MKSTREAM\n"})}),"\n",(0,i.jsx)(n.p,{children:"What it does?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Creates a consumer group named race-group ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"(can be any name)"})})]}),"\n",(0,i.jsxs)(n.li,{children:["Associated with stream ",(0,i.jsxs)(n.strong,{children:["race",":france"]})]}),"\n",(0,i.jsxs)(n.li,{children:["Starting from ID 0 (i.e., from the beginning)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0"})," Start from the beginning of the stream (include all existing messages)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$"})," Start from the latest message (only process new messages added after the group is created)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<specific-id>"})," Start from a specific stream ID like 1692900280032-0"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["If stream doesn\u2019t exist yet, ",(0,i.jsx)(n.strong,{children:"MKSTREAM"})," will create it"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"consumer-creation-optional",children:"Consumer Creation (Optional)"}),"\n",(0,i.jsx)(n.p,{children:'Think of it as: "Hey Redis, just letting you know consumer-B exists." (But it\'s not doing anything yet.)'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"XGROUP CREATECONSUMER race:france race-group consumer-B\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Creates a new consumer named ",(0,i.jsx)(n.strong,{children:"consumer-B"})]}),"\n",(0,i.jsxs)(n.li,{children:["Registers it under group race-group for stream race",":france"]}),"\n",(0,i.jsx)(n.li,{children:"Does NOT start reading any messages"}),"\n",(0,i.jsxs)(n.li,{children:["Used mainly for:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pre-registering"}),"\n",(0,i.jsxs)(n.li,{children:["Monitoring via ",(0,i.jsx)(n.code,{children:"XINFO CONSUMERS"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\u26a0\ufe0f It will fail if the group doesn\u2019t already exist.","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"(error) NOGROUP No such consumer group 'race-group' for key name 'race:france'\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"consuming-messages",children:"Consuming Messages"}),"\n",(0,i.jsx)(n.p,{children:"To actually start reading messages with a consumer:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"XREADGROUP GROUP race-group consumer-B STREAMS race:france >\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Creates consumer-B if not already exists (a shorthand of ",(0,i.jsx)(n.code,{children:"XGROUP CREATECONSUMER"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Starts consuming messages from race",":france"]}),"\n",(0,i.jsx)(n.li,{children:"Uses group race-group to track delivery, pending and acknowledgments"}),"\n",(0,i.jsx)(n.li,{children:"Will return unacknowledged messages previously sent to this consumer"}),"\n",(0,i.jsxs)(n.li,{children:["\u26a0\ufe0f It will fail if the group doesn\u2019t already exist.","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"(error) NOGROUP No such consumer group 'race-group' for key name 'race:france'\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Redis Stream entry ID options for reading","\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Symbol."}),(0,i.jsx)(n.th,{children:"Meaning"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:">"})}),(0,i.jsxs)(n.td,{children:["Get ",(0,i.jsx)(n.strong,{children:"new messages"})," not yet delivered"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"0"}),", ",(0,i.jsx)(n.code,{children:"0-0"})]}),(0,i.jsx)(n.td,{children:"Return unacknowledged messages for this group from the start (use for retries)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"<specific-id> "})}),(0,i.jsxs)(n.td,{children:["Start from only ",(0,i.jsx)(n.strong,{children:"new"})," messages going forward"]})]})]})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"full-example",children:"Full example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# 1. Create stream & group\nXGROUP CREATE race:france race-group 0 MKSTREAM\n\n# 2. (Optional) Create consumer\nXGROUP CREATECONSUMER race:france race-group consumer-B\n\n# 3. Start consuming\nXREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >\n\n# 4. Optionally: Acknowledge processed messages (Will be cover next)\nXACK race:france race-group <message-id>\n  \n"})}),"\n",(0,i.jsx)(n.h2,{id:"understanding-behavior-of-xgroup-create--0--",children:"Understanding Behavior of XGROUP CREATE ... 0 + >"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["You create a group ",(0,i.jsx)(n.code,{children:"XGROUP CREATE race:france race-group 0 MKSTREAM"})]}),"\n",(0,i.jsx)(n.li,{children:"Redis assumes this group has seen nothing yet \u2014 starting at ID 0."}),"\n",(0,i.jsxs)(n.li,{children:["When calling:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" XREADGROUP GROUP race-group consumer-B STREAMS race:france >\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Redis interprets it as:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u201cGive me entries that have not yet been delivered to anyone in this group.\u201d"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"So even if 50 messages were added earlier, they\u2019re still undelivered \u2192 Redis returns them"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"practice-1--using--to-fetch-in-batches",children:"Practice #1 \u2013 Using > to Fetch in Batches"}),"\n",(0,i.jsx)(n.p,{children:"Run this twice to observe batch consumption:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'127.0.0.1:6379> XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >\n1) 1) "race:france"\n   2)  1) 1) "1754477775952-0"\n          2) 1) "rider"\n             2) "Moreira"\n             3) "speed"\n             4) "34.4"\n             5) "position"\n             6) "1"\n             7) "location_id"\n             8) "1"\n       ....\n      10) 1) "1754477775952-9"\n          2) 1) "rider"\n             2) "Pogacar"\n             3) "speed"\n             4) "30.3"\n             5) "position"\n             6) "10"\n             7) "location_id"\n             8) "3"\n127.0.0.1:6379> XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >\n1) 1) "race:france"\n   2)  1) 1) "1754479265672-10"\n          2) 1) "rider"\n             2) "Fernandez"\n             3) "speed"\n             4) "29.6"\n             5) "position"\n             6) "11"\n             7) "location_id"\n             8) "1"\n             ,,,   \n      10) 1) "1754479265672-19"\n          2) 1) "rider"\n             2) "Lopez"\n             3) "speed"\n             4) "20.1"\n             5) "position"\n             6) "20"\n             7) "location_id"\n             8) "3"                       \n'})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Call"}),(0,i.jsx)(n.th,{children:"What Happens"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1st"}),(0,i.jsx)(n.td,{children:"Returns 10 unseen messages"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2nd"}),(0,i.jsx)(n.td,{children:"Returns next 10"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"..."}),(0,i.jsx)(n.td,{children:"Until all 50 are seen"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"After all 50"}),(0,i.jsxs)(n.td,{children:["Returns nothing until new ",(0,i.jsx)(n.code,{children:"XADD"})]})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"practice-2--using-0-to-fetch-pending-messages",children:"Practice #2 \u2013 Using 0 to Fetch Pending Messages"}),"\n",(0,i.jsx)(n.p,{children:"Fetch messages that were already delivered to this group but not yet acknowledged (in other words, pending messages)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'127.0.0.1:6379> XREADGROUP GROUP race-group consumer-B STREAMS race:france 0\n1) 1) "race:france"\n   2)  1) 1) "1754477775952-0"\n          2) 1) "rider"\n             2) "Moreira"\n             3) "speed"\n             4) "34.4"\n             5) "position"\n             6) "1"\n             7) "location_id"\n             8) "1"\n      ..... \n      20) 1) "1754477775952-19"\n          2) 1) "rider"\n             2) "Vingegaard"\n             3) "speed"\n             4) "22.2"\n             5) "position"\n             6) "20"\n             7) "location_id"\n             8) "1"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"what-it-means",children:"What it means?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Give me messages that were previously delivered to consumer-B but not yet acknowledged (aka: pending)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"In ourcase return 20 records that had been consumed."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["However, if Redis returns empty array, so:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"consumer-B has not received any messages yet"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'1) 1) "race:france"\n   2) (empty array)\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"confirm-with-xpending",children:"Confirm with XPENDING"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'XPENDING race:france race-group\n\n1) (integer) 20                       \u2190 Total **pending** (unacknowledged) messages\n2) "1754477775952-0"                  \u2190 The smallest pending message ID\n3) "1754477775952-19"                 \u2190 The largest pending message ID\n4) 1) 1) "consumer-B"                 \u2190 The only consumer with pending messages\n      2) "20"                         \u2190 Count of pending messages for consumer-B\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"consumer-B has 20 pending messages \u2192 \u2705 means Redis has delivered 20 messages to it."}),"\n",(0,i.jsxs)(n.li,{children:["The IDs range from ",(0,i.jsx)(n.code,{children:"1754477775952-0"})," to ",(0,i.jsx)(n.code,{children:"1754477775952-19"})]}),"\n",(0,i.jsx)(n.li,{children:"Those entries are still unacknowledged (you haven\u2019t called XACK)."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"adding-more-consumers",children:"Adding More Consumers"}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s create consumer-C to process more:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'# 1. (Optional) Create consumer\n> XGROUP CREATECONSUMER race:france race-group consumer-C\n\n# 2 Start consuming\n> XREADGROUP GROUP race-group consumer-C STREAMS race:france >\n\n# 3 Inspect the result\n> XPENDING race:france race-group\n1) (integer) 50\n2) "1754477775952-0"\n3) "1754477775952-49"\n4) 1) 1) "consumer-B"\n      2) "20"\n   2) 1) "consumer-C"\n      2) "30"\n'})}),"\n",(0,i.jsx)(n.p,{children:"\u2705 All 50 messages were distributed but still unacknowledged."}),"\n",(0,i.jsx)(n.h2,{id:"spring-data-redis-integration",children:"Spring Data Redis Integration"}),"\n",(0,i.jsxs)(n.admonition,{title:"Important",type:"warning",children:[(0,i.jsxs)(n.p,{children:["In each of the examples, I use ",(0,i.jsx)(n.code,{children:"FLUSHDB"})," to ensure the database starts clean. ",(0,i.jsx)(n.strong,{children:"Be careful"}),": if you have an existing Redis instance running on your local machine, ",(0,i.jsx)(n.code,{children:"FLUSHDB"})," will ",(0,i.jsx)(n.strong,{children:"delete all data in the current database"}),"."]}),(0,i.jsxs)(n.p,{children:["If you're unsure or want to avoid losing important data, the safer approach is to ",(0,i.jsx)(n.strong,{children:"delete only the specific key"}),":"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"redis-cli DEL race:france\nredis-cli --eval generate_race.lua race:france , 50\n"})})]}),"\n",(0,i.jsx)(n.p,{children:"Create spring boot project with following commands, this time we'll use h2 and Spring data JPA as well to process the data."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"spring init -d=web,data-redis,data-jpa,h2,devtools,thymeleaf,lombok \\\n  -g com.example \\\n  -a demo \\\n  -p jar \\\n  --build maven \\\n  xgroup -x\n"})}),"\n",(0,i.jsx)(n.p,{children:"add the following to application.yaml"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"spring:\n  data:\n    redis:\n      host: localhost\n      port: 6379\n  h2:\n    console:\n      enabled: true\n      path: /h2-console\n  datasource:\n    name: example\n    username: sa\n    password:\n    generate-unique-name: false\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n  sql:\n    init:\n      mode: never\n  jpa:\n    open-in-view: false\n    show-sql: true\n    generate-ddl: true\n    properties:\n      hibernate:\n        jdbc:\n          lob:\n            non_contextual_creation: true\n        format_sql: true\n        generate_statistics: true\n    hibernate:\n      ddl-auto: create-drop\n\nlogging:\n  level:\n    root: INFO\n    org:\n      springframework:\n        security: TRACE\n        web:\n          reactive:\n            function:\n              client: DEBUG\n      hibernate:\n        SQL: DEBUG\n        orm:\n          jdbc:\n            bind: TRACE\n"})}),"\n",(0,i.jsx)(n.p,{children:"RaceStreamEntity.java"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'@Entity\n@Table(name = "race_stream_entry")\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class RaceStreamEntity {\n\n    @Id\n    @GeneratedValue\n    @UuidGenerator\n    @Setter(AccessLevel.NONE)\n    private UUID id;\n\n    @Column(name = "stream_id", unique = true)\n    private String streamId; // Redis Stream ID (e.g., 1754326272465-45)\n\n    @Column(name = "rider")\n    private String rider;\n\n    @Column(name = "speed")\n    private Double speed;\n\n    @Column(name = "position")\n    private Integer position;\n\n    @Column(name = "location_id")\n    private Integer locationId;\n\n    @Column(name = "received_at")\n    private LocalDateTime receivedAt;\n\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"RaceStreamRepository.java"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"\n@Repository\npublic interface RaceStreamRepository extends JpaRepository<RaceStreamEntity, UUID>, JpaSpecificationExecutor<RaceStreamEntity> {\n\n    boolean existsByStreamId(String streamId);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"RaceStreamService.java"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class RaceStreamService {\n\n    private final StringRedisTemplate redisTemplate;\n    private final RaceStreamRepository repository;\n\n    private static final String STREAM_KEY = "race:france";\n    private static final String GROUP_NAME = "race-group";\n    private static final String CONSUMER_NAME = "consumer-B";\n    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n\n    @PostConstruct\n    public void autoStartConsumer() {\n        executor.submit(this::tailStream);\n    }\n\n    @PostConstruct\n    public void init() {\n        createGroupIfNotExists();\n    }\n\n    /*\n     *   XGROUP CREATE race:france race-group 0 MKSTREAM\n     */\n    private void createGroupIfNotExists() {\n        try {\n            redisTemplate.opsForStream().createGroup(STREAM_KEY, ReadOffset.from("0"), GROUP_NAME);\n            log.info("\u2705 Created group \'{}\' on stream \'{}\'", GROUP_NAME, STREAM_KEY);\n        } catch (RedisSystemException e) {\n            if (e.getCause() instanceof RedisBusyException) {\n                log.info("\u2139\ufe0f Group \'{}\' already exists, skipping creation", GROUP_NAME);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    @Scheduled(fixedDelay = 60000) // every 60 seconds\n    public void consumeStreamGroup() {\n        StreamOperations<String, Object, Object> streamOps = redisTemplate.opsForStream();\n\n        try {\n            /*\n             *   XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >\n             */\n            List<MapRecord<String, Object, Object>> records = streamOps.read(\n                    Consumer.from(GROUP_NAME, CONSUMER_NAME),\n                    StreamReadOptions.empty().block(Duration.ofSeconds(5)).count(10),\n                    StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed())\n            );\n\n            if (records == null || records.isEmpty()) {\n                log.debug("\u23f3 No new messages.");\n                return;\n            }\n\n            for (MapRecord<String, Object, Object> record : records) {\n                String streamId = record.getId().getValue();\n\n                if (!repository.existsByStreamId(streamId)) {\n                    RaceStreamEntity entity = toEntity(record);\n                    repository.save(entity);\n\n                    // @TODO: Acknowledge after successful save\n                } else {\n                    log.info("\u26a0\ufe0f Skipped duplicate streamId: {}", streamId);\n                }\n            }\n        } catch (DataAccessException e) {\n            log.error("\u274c Redis access error: {}", e.getMessage(), e);\n        } catch (Exception e) {\n            log.error("\u274c Unknown error in stream consumption", e);\n        }\n    }\n\n    private RaceStreamEntity toEntity(MapRecord<String, Object, Object> record) {\n        Map<Object, Object> valueMap = record.getValue();\n        return RaceStreamEntity.builder()\n                .streamId(record.getId().getValue())\n                .rider(valueMap.getOrDefault("rider", "").toString())\n                .speed(Double.parseDouble(valueMap.getOrDefault("speed", "0").toString()))\n                .position(Integer.parseInt(valueMap.getOrDefault("position", "0").toString()))\n                .locationId(Integer.parseInt(valueMap.getOrDefault("location_id", "0").toString()))\n                .receivedAt(LocalDateTime.now())\n                .build();\n    }\n\n    public void tailStream() {\n        StreamOperations<String, Object, Object> streamOps = redisTemplate.opsForStream();\n        String lastSeenId = "$"; // only new messages\n\n        while (true) {\n            try {\n                List<MapRecord<String, Object, Object>> records = streamOps.read(\n                        StreamReadOptions.empty().block(Duration.ofSeconds(10)).count(10),\n                        StreamOffset.create(STREAM_KEY, ReadOffset.from(lastSeenId))\n                );\n\n                if (records == null || records.isEmpty()) {\n                    continue; // wait again\n                }\n\n                for (MapRecord<String, Object, Object> record : records) {\n                    String streamId = record.getId().getValue();\n\n                    if (!repository.existsByStreamId(streamId)) {\n                        RaceStreamEntity entry = toEntity(record);\n                        repository.save(entry);\n                    }\n\n                    lastSeenId = streamId;\n                }\n\n            } catch (Exception ex) {\n                ex.printStackTrace(); // log and continue\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"from the DemoApplication.java"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@SpringBootApplication\n@EnableScheduling\npublic class DemoApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoApplication.class, args);\n\t}\n\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"what-the-spring-boot-program-is-doing",children:"What the Spring Boot Program Is Doing"}),"\n",(0,i.jsx)(n.p,{children:"Spring Boot program is doing stream consumption from Redis and persisting stream entries into a database, with the following key steps:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Creates the Consumer Group (Once at Startup)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@PostConstruct\npublic void init() {\n    redisTemplate.opsForStream().createGroup(STREAM_KEY, ReadOffset.from("0"), GROUP_NAME);\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This is equivalent to:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"XGROUP CREATE race:france race-group 0 MKSTREAM\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["It ensures the consumer group race-group is created for stream race",":france","."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Schedules a Consumer Task (Every 60 Seconds)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Scheduled(fixedDelay = 60000) // every 60s\npublic void consumeStreamGroup()\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"This is your background stream processor."}),"\n",(0,i.jsx)(n.li,{children:"It runs every minute to read from the Redis stream using the consumer group model."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Reads Undelivered Messages via XREADGROUP"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"streamOps.read(\n    Consumer.from(GROUP_NAME, CONSUMER_NAME),\n    StreamReadOptions.empty().block(Duration.ofSeconds(5)).count(10),\n    StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed())\n)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Equivalent Redis CLI:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"XREADGROUP GROUP race-group consumer-B COUNT 10 BLOCK 5000 STREAMS race:france >\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["What it does:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reads new messages (>) for consumer-B"}),"\n",(0,i.jsx)(n.li,{children:"Redis tracks what messages were delivered but not acknowledged"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Persists Each Entry to H2 Database"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"if (!repository.existsByStreamId(streamId)) {\n    RaceStreamEntity entity = toEntity(record);\n    repository.save(entity);\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Avoids duplicates by checking if streamId was already saved"}),"\n",(0,i.jsx)(n.li,{children:"Maps Redis stream fields (e.g., rider, speed, etc.) to a JPA entity"}),"\n",(0,i.jsx)(n.li,{children:"Stores them into your in-memory H2 table race_stream_entry"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"5. No Interruption"})}),"\n",(0,i.jsxs)(n.p,{children:["While the program is actively running\u2014but before all previous messages have been processed\u2014if you execute an ",(0,i.jsx)(n.strong,{children:"XADD"}),", the new message will still be picked up and persisted to the database without interruption."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'XADD race:france * rider "Pogacar" speed 38.9 position 1 location_id 1\n"1754485788977-0"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Unlike the @Scheduled polling approach (which may introduce delays), this tailing consumer loop continuously listens using BLOCK, allowing it to process newly added messages immediately, even while older entries are still being handled.\n\u2705 The processing is seamless and non-blocking across messages, and no messages are skipped or lost (as long as each is uniquely stored by streamId)."}),"\n",(0,i.jsx)(n.h2,{id:"-whats-missing-or-not-yet-implemented",children:"\u274c What\u2019s Missing or Not Yet Implemented?"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"You haven\u2019t acknowledged any message yet."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"in-redis-terms",children:"In Redis terms:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Messages delivered to the consumer stay in the Pending Entries List (PEL) until you XACK them."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'if (!repository.existsByStreamId(streamId)) {\n    RaceStreamEntity entity = toEntity(record);\n    repository.save(entity);\n\n    // \u2705 Acknowledge this message after successful save\n    streamOps.acknowledge(STREAM_KEY, GROUP_NAME, record.getId());\n    log.info("\u2705 Acknowledged stream ID {}", streamId);\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"This means:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Redis thinks they are still "unprocessed" or "pending retry"'}),"\n",(0,i.jsx)(n.li,{children:"If the consumer crashes or restarts, Redis will not re-deliver these messages unless you recover them manually or auto-claim them (XAUTOCLAIM / XCLAIM)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Retry Logic for Failed Saves"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If you want reliability, you can implement retry mechanisms for failed DB writes, and only XACK after success."}),"\n",(0,i.jsx)(n.li,{children:"Use XAUTOCLAIM to recover stuck messages"}),"\n",(0,i.jsx)(n.li,{children:"Add dead-letter queue if a message repeatedly fails"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Gracefully shutdown:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'@PreDestroy\npublic void shutdown() {\n    running = false;\n    executor.shutdownNow(); // Optional: force shutdown if needed\n    log.info("\ud83d\udd34 Stream consumer stopped.");\n}\n\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"best-pratices",children:"Best Pratices"}),"\n",(0,i.jsx)(n.p,{children:"In production systems, we typically avoid using @Scheduled for real-time stream consumption, especially when working with Redis Streams (or Kafka, RabbitMQ, etc.). Scheduled polling introduces latency, wasted CPU cycles, and potential inconsistencies when manually tracking offsets like the last seen record ID."}),"\n",(0,i.jsx)(n.p,{children:"Instead, a production-grade Redis Stream consumer should be designed to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Start automatically when the application starts"}),"\n",(0,i.jsx)(n.li,{children:"Run in a continuous background thread or task"}),"\n",(0,i.jsx)(n.li,{children:"Use XREADGROUP with BLOCK to efficiently wait for new messages in an event-driven manner"}),"\n",(0,i.jsx)(n.li,{children:"Use XACK after successful processing to let Redis handle delivery state"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\ud83d\udc49 This approach simulates the ideal pattern for overcoming previous issues with XREAD, where developers had to manually track and persist the last seen ID (e.g. via $, specific stream ID, or 0-0).\nBy using XREADGROUP with BLOCK, Redis remembers what messages have or haven\u2019t been delivered to each consumer group, and automatically resumes from the correct position \u2014 eliminating the need to self-manage offset tracking.\nThe thread is only interrupted when new data arrives or during shutdown, ensuring high efficiency and reliability in stream processing."}),"\n",(0,i.jsx)(n.h3,{id:"1-kick-off-consumer-in-postconstruct-or-eventlistener",children:"1. Kick Off Consumer in @PostConstruct or @EventListener"}),"\n",(0,i.jsx)(n.p,{children:"Either of these works:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@PostConstruct\npublic void startConsumerThread() { ... }\n\n-- or --\n\n@EventListener(ApplicationReadyEvent.class)\npublic void startConsumerThread() { ... }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2--use-a-long-running-background-thread",children:"2.  Use a Long-Running Background Thread"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Executors.newSingleThreadExecutor().submit(() -> {\n    while (true) {\n        List<MapRecord<String, Object, Object>> records = redisTemplate.opsForStream().read(\n            Consumer.from("race-group", "consumer-B"),\n            StreamReadOptions.empty().block(Duration.ofSeconds(30)).count(10),\n            StreamOffset.create("race:france", ReadOffset.lastConsumed())\n        );\n\n        for (MapRecord<String, Object, Object> record : records) {\n            // process and XACK\n        }\n    }\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Slf4j\n@Component\n@RequiredArgsConstructor\npublic class RaceStreamConsumer {\n\n    private final StringRedisTemplate redisTemplate;\n    private final RaceStreamRepository repository;\n\n    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n    private volatile boolean running = true;\n\n    private static final String STREAM_KEY = "race:france";\n    private static final String GROUP_NAME = "race-group";\n    private static final String CONSUMER_NAME = "consumer-B";\n\n    @PostConstruct\n    public void init() {\n        createGroupIfNotExists();\n    }\n\n    /*\n     *   XGROUP CREATE race:france race-group 0 MKSTREAM\n     */\n    private void createGroupIfNotExists() {\n        try {\n            redisTemplate.opsForStream().createGroup(STREAM_KEY, ReadOffset.from("0"), GROUP_NAME);\n            log.info("\u2705 Created group \'{}\' on stream \'{}\'", GROUP_NAME, STREAM_KEY);\n        } catch (RedisSystemException e) {\n            if (e.getCause() instanceof RedisBusyException) {\n                log.info("\u2139\ufe0f Group \'{}\' already exists, skipping creation", GROUP_NAME);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    @EventListener(ApplicationReadyEvent.class)\n    public void startConsumerThread() {\n        executor.submit(() -> {\n            while (running) {\n                try {\n                    List<MapRecord<String, Object, Object>> records = redisTemplate.opsForStream().read(\n                            Consumer.from(GROUP_NAME, CONSUMER_NAME),\n                            StreamReadOptions.empty().block(Duration.ofSeconds(30)).count(10),\n                            StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed())\n                    );\n\n                    if (records == null || records.isEmpty()) {\n                        continue; // Wait again\n                    }\n\n                    for (MapRecord<String, Object, Object> record : records) {\n                        String streamId = record.getId().getValue();\n\n                        if (!repository.existsByStreamId(streamId)) {\n                            repository.save(toEntity(record));\n                            redisTemplate.opsForStream().acknowledge(STREAM_KEY, GROUP_NAME, record.getId());\n                        }\n                    }\n                } catch (Exception e) {\n                    log.error("Stream processing error", e);\n\n                    try {\n                        Thread.sleep(1000); // Optional backoff\n                    } catch (InterruptedException ie) {\n                        Thread.currentThread().interrupt();\n                        break;\n                    }\n                }\n            }\n\n            log.info("\ud83d\uded1 Redis Stream consumer has stopped.");\n        });\n    }\n\n    @PreDestroy\n    public void shutdownConsumer() {\n        running = false;\n        executor.shutdownNow(); // Optional: force interrupt\n        log.info("\ud83d\udd34 Graceful shutdown triggered for Redis consumer.");\n    }\n\n    private RaceStreamEntity toEntity(MapRecord<String, Object, Object> record) {\n        Map<Object, Object> m = record.getValue();\n\n        return RaceStreamEntity.builder()\n                .streamId(record.getId().getValue())\n                .rider(String.valueOf(m.get("rider")))\n                .speed(Double.valueOf(String.valueOf(m.get("speed"))))\n                .position(Integer.valueOf(String.valueOf(m.get("position"))))\n                .locationId(Integer.valueOf(String.valueOf(m.get("location_id"))))\n                .receivedAt(LocalDateTime.now())\n                .build();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"additional-information-on-block",children:"Additional Information on BLOCK"}),"\n",(0,i.jsx)(n.p,{children:"Redis is single-threaded for command execution, but your Java program is not \u2014 and BLOCK 0 (or BLOCK N) doesn't block Redis itself; it only blocks the client connection (your thread), not the server."}),"\n",(0,i.jsx)(n.h4,{id:"key-understanding-who-is-blocking-whom",children:"Key Understanding: Who Is Blocking Whom?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"BLOCK"})," blocks the client-side connection, not Redis."]}),"\n",(0,i.jsxs)(n.li,{children:["When you call:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"XREAD BLOCK 0 STREAMS race:france >\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Redis does not block its own execution"}),"\n",(0,i.jsx)(n.li,{children:"It just holds that one client connection open, waiting for new data"}),"\n",(0,i.jsx)(n.li,{children:"Other clients (your app, other services) can still run commands freely"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"BLOCK"})," is not a sleep, it is a timeout","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u201cWait up to 30 seconds for a message to arrive."}),"\n",(0,i.jsx)(n.li,{children:"If a message comes in earlier, return immediately."}),"\n",(0,i.jsx)(n.li,{children:"If nothing arrives within 30 seconds, return null.\u201d"}),"\n",(0,i.jsx)(n.li,{children:"\u26d4 It does not idle or sleep for 30 seconds after returning."}),"\n",(0,i.jsx)(n.li,{children:"\u2705 It just returns immediately, and your code continues executing."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"timeline-visualization",children:"Timeline Visualization"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Time (s)"}),(0,i.jsx)(n.th,{children:"Event"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0"}),(0,i.jsxs)(n.td,{children:["You call ",(0,i.jsx)(n.code,{children:".read(BLOCK 30)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"30"}),(0,i.jsxs)(n.td,{children:["No message \u2014 Redis returns ",(0,i.jsx)(n.code,{children:"null"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"30\u201335"}),(0,i.jsxs)(n.td,{children:["Your code loops again, calls ",(0,i.jsx)(n.code,{children:".read(BLOCK 30)"})," again"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"35"}),(0,i.jsx)(n.td,{children:"Message arrives"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"35\u201336"}),(0,i.jsx)(n.td,{children:"Redis immediately returns the message to the new read()"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"36+"}),(0,i.jsx)(n.td,{children:"Your code processes the message"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"analogy",children:"Analogy"}),"\n",(0,i.jsx)(n.p,{children:"Imagine Redis as a waiter:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'You (client A) say: "Wait at my table until food is ready." (BLOCK)'}),"\n",(0,i.jsx)(n.li,{children:"The waiter just keeps your request on hold"}),"\n",(0,i.jsx)(n.li,{children:"Meanwhile, the waiter continues to serve other tables (clients)"}),"\n",(0,i.jsx)(n.li,{children:"When food (message) is ready, the waiter replies to you"}),"\n",(0,i.jsx)(n.li,{children:"So Redis is not blocked. Just your request is suspended until fulfilled."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"in-java-terms",children:"In Java Terms"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"List<MapRecord<...>> records = streamOps.read(... BLOCK 0 ...);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"This blocks only that Java thread (e.g. inside your Runnable / Executor)"}),"\n",(0,i.jsx)(n.li,{children:"Redis is totally fine \u2014 other operations like XADD, XINFO, or even other consumers continue running"}),"\n",(0,i.jsx)(n.li,{children:"Your app can run hundreds of threads, each with their own BLOCK calls, if needed"}),"\n",(0,i.jsx)(n.li,{children:"You Can Safely Use BLOCK 0 in Production"}),"\n",(0,i.jsxs)(n.li,{children:["The only ",(0,i.jsx)(n.strong,{children:"drawback"})," is graceful shutdown more difficult \u2014 not impossible, but you\u2019ll need extra work to support it."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"List<MapRecord<...>> records = streamOps.read(... BLOCK 5 or 10 ...);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast enough for near real-time"}),"\n",(0,i.jsx)(n.li,{children:"Easy to exit on shutdown (running flag)"}),"\n",(0,i.jsx)(n.li,{children:"You don\u2019t need ultra-low latency (sub-second responsiveness)"}),"\n",(0,i.jsx)(n.li,{children:"Your thread will resume and do a null check every 5s or 10s depends what you set it"}),"\n",(0,i.jsx)(n.li,{children:"Slight increase in Redis commands, Redis receives a command every 30s per consumer"}),"\n",(0,i.jsx)(n.li,{children:"Slight latency on arrival. If a message arrives at second 0.1, your code may not see it until second 30 (worst case)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Use Case"}),(0,i.jsx)(n.th,{children:"Create consumer?"}),(0,i.jsxs)(n.th,{children:["Use ",(0,i.jsx)(n.code,{children:"XREADGROUP"}),"?"]}),(0,i.jsxs)(n.th,{children:["Use ",(0,i.jsx)(n.code,{children:"XREAD"}),"?"]})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Single user reads stream"}),(0,i.jsx)(n.td,{children:"\u274c No"}),(0,i.jsx)(n.td,{children:"\u274c No"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Multiple consumers (shared work)"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"}),(0,i.jsx)(n.td,{children:"\u274c No"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Need retries, reliability"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"}),(0,i.jsx)(n.td,{children:"\u274c No"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Redis tracks:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each consumer (e.g., consumer-1, consumer-2)"}),"\n",(0,i.jsx)(n.li,{children:"Which message was delivered to which consumer"}),"\n",(0,i.jsx)(n.li,{children:"Which messages are pending acknowledgment"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);
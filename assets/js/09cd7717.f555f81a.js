"use strict";(self.webpackChunkredis=self.webpackChunkredis||[]).push([[5225],{575:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"tutorial-basics/xtrim","title":"Maintenance with XTRIM","description":"Over time, a Redis Stream can grow very large if we keep appending new entries without any cleanup.","source":"@site/docs/tutorial-basics/13-xtrim.mdx","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/xtrim","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xtrim","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/13-xtrim.mdx","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"sidebar_position":13,"title":"Maintenance with XTRIM"},"sidebar":"tutorialSidebar","previous":{"title":"XPENDING","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xpending"},"next":{"title":"Redis Stream Consumer Boilerplate","permalink":"/spring-data-redis-streams/docs/tutorial-basics/best-practice"}}');var r=i(4848),t=i(8453);const a={sidebar_position:13,title:"Maintenance with XTRIM"},d="Maintenance with XTRIM",l={},c=[{value:"Why We Need XTRIM",id:"why-we-need-xtrim",level:2},{value:"XTRIM Basics",id:"xtrim-basics",level:2},{value:"Keep only the newest 1,000 entries",id:"keep-only-the-newest-1000-entries",level:3},{value:"Keep only entries newer than a specific ID",id:"keep-only-entries-newer-than-a-specific-id",level:3},{value:"Using XPENDING to Find the Oldest ID",id:"using-xpending-to-find-the-oldest-id",level:3},{value:"Putting It All Together: Maintenance Script",id:"putting-it-all-together-maintenance-script",level:2},{value:"Example in Spring Data Redis:",id:"example-in-spring-data-redis",level:3},{value:"Best Practice",id:"best-practice",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"maintenance-with-xtrim",children:"Maintenance with XTRIM"})}),"\n",(0,r.jsxs)(n.p,{children:["Over time, a Redis Stream can grow ",(0,r.jsx)(n.strong,{children:"very large"})," if we keep appending new entries without any cleanup."]}),"\n",(0,r.jsxs)(n.p,{children:["While Redis Streams are append-only and designed for high write throughput, excessive growth can impact ",(0,r.jsx)(n.strong,{children:"memory usage"}),", ",(0,r.jsx)(n.strong,{children:"performance of range queries"}),", and ",(0,r.jsx)(n.strong,{children:"stream management commands"})," like ",(0,r.jsx)(n.code,{children:"XRANGE"}),", ",(0,r.jsx)(n.code,{children:"XPENDING"}),", or ",(0,r.jsx)(n.code,{children:"XREADGROUP"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In this guide, we will see why ",(0,r.jsx)(n.code,{children:"XTRIM"})," is useful, and how we can use it alongside ",(0,r.jsx)(n.code,{children:"XPENDING"})," to perform ",(0,r.jsx)(n.strong,{children:"targeted stream maintenance"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"why-we-need-xtrim",children:"Why We Need XTRIM"}),"\n",(0,r.jsx)(n.p,{children:"Every stream entry consumes memory. In long-running systems, streams can accumulate millions of entries \u2014 many of which may already be acknowledged and no longer needed."}),"\n",(0,r.jsxs)(n.p,{children:["Potential issues with ",(0,r.jsx)(n.strong,{children:"unbounded stream growth"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Higher memory consumption."}),"\n",(0,r.jsxs)(n.li,{children:["Slower stream traversal (",(0,r.jsx)(n.code,{children:"XRANGE"}),", ",(0,r.jsx)(n.code,{children:"XREADGROUP"}),")."]}),"\n",(0,r.jsx)(n.li,{children:"Slower recovery/idle message scans due to a larger pending list."}),"\n",(0,r.jsxs)(n.li,{children:["Difficulty performing housekeeping (e.g., snapshotting, replaying data).\n",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"XTRIM"})})," solves this by removing older entries from a stream."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"xtrim-basics",children:"XTRIM Basics"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"XTRIM"})," command removes entries from a stream based on either:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MAXLEN"})," \u2014 Keep only the most recent ",(0,r.jsx)(n.code,{children:"N"})," entries."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MINID"})," \u2014 Keep only entries with IDs greater than or equal to a given ID."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Examples:"}),"\n",(0,r.jsx)(n.h3,{id:"keep-only-the-newest-1000-entries",children:"Keep only the newest 1,000 entries"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"XTRIM mystream MAXLEN 1000\n"})}),"\n",(0,r.jsx)(n.h3,{id:"keep-only-entries-newer-than-a-specific-id",children:"Keep only entries newer than a specific ID"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"XTRIM mystream MINID 1688459100000-0\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-xpending-to-find-the-oldest-id",children:"Using XPENDING to Find the Oldest ID"}),"\n",(0,r.jsx)(n.p,{children:"If you\u2019re working with consumer groups, you may want to trim only entries that are no longer pending for processing."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"XPENDING"})," can help identify the oldest message in the group:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"XPENDING race:france race-group - + 1\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example result:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'1) 1) "1642165671234-0"  # Oldest ID\n   2) "consumer-A"\n   3) (integer) 12345    # ms since last delivery\n   4) (integer) 1        # Delivery count\n'})}),"\n",(0,r.jsx)(n.p,{children:"Once you have this oldest pending ID, you can trim everything before it:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"XTRIM race:france MINID 1642165671234-0\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"This ensures you:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keep pending messages intact."}),"\n",(0,r.jsx)(n.li,{children:"Remove only messages that are fully processed by all consumers."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"putting-it-all-together-maintenance-script",children:"Putting It All Together: Maintenance Script"}),"\n",(0,r.jsx)(n.p,{children:"Example in Redis CLI:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Step 1: Find the oldest pending message ID"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"OLD_ID=$(redis-cli --raw XPENDING race:france race-group - + 1 | head -n 1)\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Step 2: If no pending, use latest consumed ID or safe checkpoint"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Step 3: Trim the stream before that ID"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"XTRIM race:france MINID $OLD_ID\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-in-spring-data-redis",children:"Example in Spring Data Redis:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"PendingMessages pending = redisTemplate.opsForStream().pending(STREAM_KEY, GROUP_NAME,\n    Range.unbounded(), 1);\n\nif (!pending.isEmpty()) {\n    String oldestId = pending.get(0).getIdAsString();\n    redisTemplate.opsForStream().trim(STREAM_KEY, TrimStrategy.minId(oldestId));\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"best-practice",children:"Best Practice"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Run trimming periodically (e.g., via a scheduled job)."}),"\n",(0,r.jsxs)(n.li,{children:["Monitor stream length with ",(0,r.jsx)(n.code,{children:"XLEN"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Always trim after acknowledging messages, never before."}),"\n",(0,r.jsx)(n.li,{children:"If possible, checkpoint last processed IDs to avoid accidental deletion of needed data."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["With ",(0,r.jsx)(n.code,{children:"XPENDING"})," + ",(0,r.jsx)(n.code,{children:"XTRIM"}),", you keep your streams lean, your memory footprint under control, and your read operations consistently fast \u2014 even after running for months or years."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>d});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);
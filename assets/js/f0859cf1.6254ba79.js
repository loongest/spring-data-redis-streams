"use strict";(self.webpackChunkredis=self.webpackChunkredis||[]).push([[6375],{6327:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"tutorial-basics/xread","title":"XREAD","description":"XREAD is a Redis command used to read entries from one or more Redis Streams. It can read both historical and new entries, and it supports optional blocking \u2014 much like tail -f on a log file.","source":"@site/docs/tutorial-basics/07-xread.mdx","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/xread","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xread","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/07-xread.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"XINFO STREAM","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xinfo-stream"},"next":{"title":"XGROUP ...","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xgroup-consumer"}}');var t=r(4848),i=r(8453);const a={sidebar_position:7},o="XREAD",d={},l=[{value:"Syntax",id:"syntax",level:2},{value:"Behavior",id:"behavior",level:2},{value:"Analogy",id:"analogy",level:2},{value:"When to use?",id:"when-to-use",level:2},{value:"Redis CLI",id:"redis-cli",level:2},{value:"Important Behaviors",id:"important-behaviors",level:2},{value:"Real-world implication",id:"real-world-implication",level:3},{value:"How to consume past + future safely?",id:"how-to-consume-past--future-safely",level:3},{value:"No Consumer Groups Yet",id:"no-consumer-groups-yet",level:2},{value:"What\u2019s Next?",id:"whats-next",level:2},{value:"Spring Data Redis",id:"spring-data-redis",level:2},{value:"Better approach for real-world consumers",id:"better-approach-for-real-world-consumers",level:3}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"xread",children:"XREAD"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"XREAD"})})," is a Redis command used to read entries from one or more Redis Streams. It can read both historical and new entries, and it supports optional blocking \u2014 much like ",(0,t.jsx)(n.code,{children:"tail -f"})," on a log file."]}),"\n",(0,t.jsxs)(n.p,{children:["Think of ",(0,t.jsx)(n.code,{children:"XREAD"})," as a simple, ",(0,t.jsx)(n.strong,{children:"single-consumer"})," reader \u2014 ideal for standalone Java apps, CLI tools, or batch jobs that don\u2019t require distributed coordination."]}),"\n",(0,t.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XREAD [COUNT <count>] [BLOCK <milliseconds>] STREAMS <stream1> [stream2 ...] <id1> [id2 ...]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"behavior",children:"Behavior"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Reads entries ",(0,t.jsx)(n.strong,{children:"starting from a specific ID"})]}),"\n",(0,t.jsxs)(n.li,{children:["Can ",(0,t.jsx)(n.strong,{children:"block"})," and wait for new messages (",(0,t.jsx)(n.code,{children:"BLOCK"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Has ",(0,t.jsx)(n.strong,{children:"no acknowledgment"})," mechanism"]}),"\n",(0,t.jsxs)(n.li,{children:["Does ",(0,t.jsx)(n.strong,{children:"not track read position"})]}),"\n",(0,t.jsx)(n.li,{children:"Suitable for simple, fire-and-forget scenarios"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"analogy",children:"Analogy"}),"\n",(0,t.jsxs)(n.p,{children:["Think of ",(0,t.jsx)(n.code,{children:"XREAD"})," like running linux command. It just reads data. Nothing is tracked. No coordination. No state."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"tail -f log.txt\n"})}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use",children:"When to use?"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"Recommended?"}),(0,t.jsx)(n.th,{children:"Notes"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Standalone Java app reading a stream"}),(0,t.jsx)(n.td,{children:"\u2705 Yes"}),(0,t.jsx)(n.td,{children:"No need for consumer group overhead"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Batch job reading all stream data once"}),(0,t.jsx)(n.td,{children:"\u2705 Yes"}),(0,t.jsx)(n.td,{children:"Simple linear read; no state tracking required"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Real-time processing by a single process"}),(0,t.jsx)(n.td,{children:"\u2705 Yes"}),(0,t.jsxs)(n.td,{children:["Use ",(0,t.jsx)(n.code,{children:"BLOCK"})," for push-like behavior"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Multiple consumers / coordinated reading"}),(0,t.jsx)(n.td,{children:"\u274c No"}),(0,t.jsxs)(n.td,{children:["Use ",(0,t.jsx)(n.code,{children:"XREADGROUP"})," + Consumer Groups instead"]})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"redis-cli",children:"Redis CLI"}),"\n",(0,t.jsxs)(n.p,{children:["We\u2019ll reuse the race",":france"," stream created earlier for these examples."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Read from begining of one stream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XREAD STREAMS race:france 0\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reads all available entries starting from the start (ID = 0)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Read Only New Messages (Real-time)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XREAD BLOCK 0 STREAMS race:france $\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BLOCK 0"})," \u2192 wait forever (like tail -f) until new data arrives"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"$"})," \u2192 start reading from new entries only (ignore past history)"]}),"\n",(0,t.jsxs)(n.li,{children:["In a separate terminal, add a new entry:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'XADD race:france * rider "Vingegaard" speed "33.5"\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Read from multiple streams"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XREAD STREAMS stream1 stream2 0 0\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Returns up to 2 entries from mystream, starting at the beginning"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Read single entry from streams"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'127.0.0.1:6379> xread count 1 streams race:france 1754326272465-15\n1) 1) "race:france"\n  2) 1) 1) "1754326272465-16"\n        2) 1) "rider"\n            2) "Lopez"\n            3) "speed"\n            4) "26.6"\n            5) "position"\n            6) "17"\n            7) "location_id"\n            8) "1"\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Redis returns only entries with IDs greater than the one you specify."}),"\n",(0,t.jsx)(n.li,{children:"However this is confuse, as only items with IDs greater than the one provided are returned"}),"\n",(0,t.jsx)(n.li,{children:'In this exampole, Redis searches for the next ID > 1754326272465-15, and finds "1754326272465-16"'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"important-behaviors",children:"Important Behaviors"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"What happens?"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:["You use ",(0,t.jsx)(n.code,{children:"XREAD STREAMS mystream 0"})]}),(0,t.jsxs)(n.td,{children:["\u2705 Reads ",(0,t.jsx)(n.strong,{children:"from the beginning"})," (gets all past messages)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:["You use ",(0,t.jsx)(n.code,{children:"XREAD STREAMS mystream <specific-id>"})]}),(0,t.jsxs)(n.td,{children:["\u2705 Reads from ",(0,t.jsx)(n.strong,{children:"that point forward (exclusive)"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:["You use ",(0,t.jsx)(n.code,{children:"XREAD STREAMS mystream $"})]}),(0,t.jsxs)(n.td,{children:["\u274c Skips all existing messages; waits for ",(0,t.jsx)(n.strong,{children:"new ones only"})]})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"real-world-implication",children:"Real-world implication"}),"\n",(0,t.jsx)(n.p,{children:"If the stream already has thousands of entries and you do:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XREAD BLOCK 0 STREAMS race:france $\n"})}),"\n",(0,t.jsx)(n.p,{children:"You will not receive any past data \u2014 it only waits for new messages."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"That\u2019s great for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Real-time log tailing"}),"\n",(0,t.jsx)(n.li,{children:"Event subscribers that only care about new events"}),"\n",(0,t.jsx)(n.li,{children:"But not suitable if you want to process old data."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"how-to-consume-past--future-safely",children:"How to consume past + future safely?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Step 1"}),": Backfill History"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XREAD COUNT 100 STREAMS race:france 0\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Repeat until you\u2019ve read up to the last known ID."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Step 2"}),": Switch to Real-time"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XREAD BLOCK 0 STREAMS race:france 1754326272465-99\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Then switch to XREAD BLOCK 0 STREAMS mystream ",(0,t.jsx)(n.code,{children:"<last-seen-id>"})]}),"\n",(0,t.jsx)(n.li,{children:"This lets you continue from where you left off and receive new messages."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"no-consumer-groups-yet",children:"No Consumer Groups Yet"}),"\n",(0,t.jsx)(n.p,{children:"We\u2019re not covering consumer groups yet."}),"\n",(0,t.jsx)(n.p,{children:"For simple apps, you don\u2019t need to create consumers or groups \u2014 just read directly and track progress in your app (e.g. in memory, DB, file, etc.)."}),"\n",(0,t.jsx)(n.p,{children:"Remember:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Redis Streams are append-only logs"}),"\n",(0,t.jsx)(n.li,{children:"Messages stay in Redis until explicitly deleted (e.g. via XTRIM, XDEL, or eviction)."}),"\n",(0,t.jsx)(n.li,{children:"Redis does not track any \u201cread\u201d position for you unless you use Consumer Groups."}),"\n",(0,t.jsx)(n.li,{children:"So when using plain XREAD or XRANGE, you must track the last seen ID in your own code (e.g. in a DB, local file, in-memory var, etc.)."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"whats-next",children:"What\u2019s Next?"}),"\n",(0,t.jsx)(n.p,{children:"We\u2019ll build a Spring Boot app that uses XREAD to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Load past messages as a one-time backfill"}),"\n",(0,t.jsx)(n.li,{children:"Then switch to blocking read for live updates\nThe producer (you) will send new entries via XADD in Redis CLI."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"spring-data-redis",children:"Spring Data Redis"}),"\n",(0,t.jsx)(n.p,{children:"Create spring boot project with following commands, this time we'll use h2 and Spring data JPA as well to process the data."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"spring init -d=web,data-redis,data-jpa,h2,devtools,thymeleaf,lombok \\\n  -g com.example \\\n  -a demo \\\n  -p jar \\\n  --build maven \\\n  xread -x\n"})}),"\n",(0,t.jsx)(n.p,{children:"add the following to application.yaml"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"spring:\n  data:\n    redis:\n      host: localhost\n      port: 6379\n  h2:\n    console:\n      enabled: true\n      path: /h2-console\n  datasource:\n    name: example\n    username: sa\n    password:\n    generate-unique-name: false\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n  sql:\n    init:\n      mode: never\n  jpa:\n    open-in-view: false\n    show-sql: true\n    generate-ddl: true\n    properties:\n      hibernate:\n        jdbc:\n          lob:\n            non_contextual_creation: true\n        format_sql: true\n        generate_statistics: true\n    hibernate:\n      ddl-auto: create-drop\n\nlogging:\n  level:\n    root: INFO\n    org:\n      springframework:\n        security: TRACE\n        web:\n          reactive:\n            function:\n              client: DEBUG\n      hibernate:\n        SQL: DEBUG\n        orm:\n          jdbc:\n            bind: TRACE\n"})}),"\n",(0,t.jsx)(n.p,{children:"RaceStreamEntity.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'@Entity\n@Table(name = "race_stream_entry")\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class RaceStreamEntity {\n\n    @Id\n    @GeneratedValue\n    @UuidGenerator\n    @Setter(AccessLevel.NONE)\n    private UUID id;\n\n    @Column(name = "stream_id", unique = true)\n    private String streamId; // Redis Stream ID (e.g., 1754326272465-45)\n\n    @Column(name = "rider")\n    private String rider;\n\n    @Column(name = "speed")\n    private Double speed;\n\n    @Column(name = "position")\n    private Integer position;\n\n    @Column(name = "location_id")\n    private Integer locationId;\n\n    @Column(name = "received_at")\n    private LocalDateTime receivedAt;\n\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"RaceStreamRepository.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"\n@Repository\npublic interface RaceStreamRepository extends JpaRepository<RaceStreamEntity, UUID>, JpaSpecificationExecutor<RaceStreamEntity> {\n\n    boolean existsByStreamId(String streamId);\n\n    Optional<RaceStreamEntity> findTopByOrderByReceivedAtDesc();\n\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"RaceStreamService.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"public interface RaceStreamService {\n\n    void readHistorical();\n\n    void tailStream();\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"RaceStreamServiceImpl.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class RaceStreamServiceImpl implements RaceStreamService {\n\n    private final StringRedisTemplate redisTemplate;\n    private final RaceStreamRepository repository;\n    private static final String STREAM_KEY = "race:france";\n    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n\n    @PostConstruct\n    public void autoStartConsumer() {\n        executor.submit(this::tailStream);\n    }\n\n    @Scheduled(fixedRate = 10_000) // every 10 second\n    public void scheduledReadHistorical() {\n        System.out.println("[Scheduler] Run # Executing readHistorical()");\n        readHistorical();\n    }\n\n    @Override\n    public void readHistorical() {\n\n        String lastSeenId = repository.findTopByOrderByReceivedAtDesc()\n                .map(RaceStreamEntity::getStreamId)\n                .orElse("0");\n\n\n        StreamOperations<String, Object, Object> streamOps = redisTemplate.opsForStream();\n\n        // Read up to 10 entries in a single call\n        List<MapRecord<String, Object, Object>> records = streamOps.read(\n                StreamReadOptions.empty().count(10),\n                StreamOffset.create(STREAM_KEY, ReadOffset.from(lastSeenId))\n        );\n\n        if (records == null || records.isEmpty()) {\n            return; // nothing to process\n        }\n\n        for (MapRecord<String, Object, Object> record : records) {\n            String streamId = record.getId().getValue();\n\n            if (!repository.existsByStreamId(streamId)) {\n                RaceStreamEntity entity = toEntity(record);\n                repository.save(entity);\n            }\n            lastSeenId = streamId; // \u2705 advance pointer (if needed)\n        }\n        log.info("\u2705 Last processed streamId: {}", lastSeenId);\n\n    }\n\n    @Override\n    public void tailStream() {\n        StreamOperations<String, Object, Object> streamOps = redisTemplate.opsForStream();\n        String lastSeenId = "$"; // only new messages\n\n        while (true) {\n            try {\n                List<MapRecord<String, Object, Object>> records = streamOps.read(\n                        StreamReadOptions.empty().block(Duration.ofSeconds(10)).count(10),\n                        StreamOffset.create(STREAM_KEY, ReadOffset.from(lastSeenId))\n                );\n\n                if (records == null || records.isEmpty()) {\n                    continue; // wait again\n                }\n\n                for (MapRecord<String, Object, Object> record : records) {\n                    String streamId = record.getId().getValue();\n\n                    if (!repository.existsByStreamId(streamId)) {\n                        RaceStreamEntity entry = toEntity(record);\n                        repository.save(entry);\n                    }\n\n                    lastSeenId = streamId;\n                }\n\n            } catch (Exception ex) {\n                ex.printStackTrace(); // log and continue\n            }\n        }\n    }\n\n    private RaceStreamEntity toEntity(MapRecord<String, Object, Object> record) {\n        Map<Object, Object> valueMap = record.getValue();\n        return RaceStreamEntity.builder()\n                .streamId(record.getId().getValue())\n                .rider(valueMap.getOrDefault("rider", "").toString())\n                .speed(Double.valueOf(valueMap.getOrDefault("speed", "0").toString()))\n                .position(Integer.valueOf(valueMap.getOrDefault("position", "0").toString()))\n                .locationId(Integer.valueOf(valueMap.getOrDefault("location_id", "0").toString()))\n                .receivedAt(LocalDateTime.now())\n                .build();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"from the DemoApplication.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import lombok.RequiredArgsConstructor;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.data.domain.Range;\nimport org.springframework.data.redis.connection.stream.MapRecord;\nimport org.springframework.data.redis.core.StreamOperations;\nimport org.springframework.data.redis.connection.Limit;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\n\n@SpringBootApplication\n@EnableScheduling\npublic class DemoApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoApplication.class, args);\n\t}\n\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this example, we demonstrate how to use the receivedAt field (i.e., the last processed record's stream ID) to resume reading from a Redis stream. Based on this ID, we continue querying for subsequent stream entries. Additionally, we enable blocking behavior to wait for any new incoming entries."}),"\n",(0,t.jsx)(n.p,{children:"While this approach appears to work smoothly, there\u2019s a critical drawback."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Scenario:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You're reading 10 old records starting from ID 100-0 up to 109-0."}),"\n",(0,t.jsx)(n.li,{children:"While you're still processing record 105-0, a new entry 200-0 is added."}),"\n",(0,t.jsx)(n.li,{children:"Your logic stores 200-0 in DB and updates receivedAt = 200-0."}),"\n",(0,t.jsx)(n.li,{children:"Now, records 106-0 to 199-0 are skipped forever, unless you backtrack manually."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'If a new stream entry arrives while we\'re still processing historical records, and we process and store that new entry first, our "last seen ID" gets prematurely updated to this newer ID. As a result, any unprocessed entries between the old and new IDs may be skipped permanently, and never picked up again.'}),"\n",(0,t.jsx)(n.p,{children:"To avoid this, it's better not to manage the offset ourselves. Instead, we should rely on Redis consumer groups, which are specifically designed to track the delivery state per consumer, ensuring we always resume exactly where we left off \u2014 without gaps or duplicates."}),"\n",(0,t.jsx)(n.p,{children:"In short:\n\ud83d\udc49 Consumers should be stateless and dumb \u2014 let Redis tell us what to process next."}),"\n",(0,t.jsxs)(n.admonition,{title:"tips",type:"success",children:[(0,t.jsx)(n.h3,{id:"better-approach-for-real-world-consumers",children:"Better approach for real-world consumers"}),(0,t.jsx)(n.p,{children:"Use Consumer Groups + XREADGROUP:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XGROUP CREATE mystream mygroup 0    # Create once\nXREADGROUP GROUP mygroup consumerA COUNT 10 BLOCK 0 STREAMS mystream >\n"})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 Will receive unprocessed historical messages"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Progress tracked per group"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Avoids duplication"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Supports XACK to acknowledge processed messages"}),"\n"]}),(0,t.jsx)(n.p,{children:"We\u2019ll cover Consumer Groups in the next section."})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);
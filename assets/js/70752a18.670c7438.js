"use strict";(self.webpackChunkredis=self.webpackChunkredis||[]).push([[1970],{382:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"tutorial-basics/xclaim","title":"XCLAIM","description":"We\'ve cover quite a lot so far, let\u2019s now explore how to identify and handle failed entries (i.e., pending messages that were never acknowledged due to errors or consumer crashes).","source":"@site/docs/tutorial-basics/10-xclaim.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/xclaim","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xclaim","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/10-xclaim.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"XACK","permalink":"/spring-data-redis-streams/docs/tutorial-basics/xack"}}');var t=s(4848),i=s(8453);const a={sidebar_position:10},o="XCLAIM",c={},d=[{value:"View Failed / Stuck Pending Entries with XPENDING",id:"view-failed--stuck-pending-entries-with-xpending",level:2},{value:"Automatically Claim Stuck Messages with XAUTOCLAIM",id:"automatically-claim-stuck-messages-with-xautoclaim",level:2},{value:"Spring Data Redis Example: Auto-Reclaim Failed Messages",id:"spring-data-redis-example-auto-reclaim-failed-messages",level:2},{value:"Example",id:"example",level:3},{value:"Entity and Repository",id:"entity-and-repository",level:3},{value:"StreamRecoveryService",id:"streamrecoveryservice",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Step-by-Step: Simulate Stuck Message for Recovery",id:"step-by-step-simulate-stuck-message-for-recovery",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"xclaim",children:"XCLAIM"})}),"\n",(0,t.jsx)(n.p,{children:"We've cover quite a lot so far, let\u2019s now explore how to identify and handle failed entries (i.e., pending messages that were never acknowledged due to errors or consumer crashes)."}),"\n",(0,t.jsx)(n.p,{children:"These messages stay in the Pending Entries List (PEL) until they are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Successfully acknowledged (XACK)"}),"\n",(0,t.jsx)(n.li,{children:"Reclaimed via XCLAIM or XAUTOCLAIM"}),"\n",(0,t.jsx)(n.li,{children:"Expire due to a TTL policy (Redis doesn\u2019t do this automatically)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"view-failed--stuck-pending-entries-with-xpending",children:"View Failed / Stuck Pending Entries with XPENDING"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XPENDING race:france race-group - + 10\n"})}),"\n",(0,t.jsx)(n.p,{children:"This lists the first 10 pending messages, with details:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'1) 1) "1754490516011-21"     # Stream ID\n   2) "consumer-B"           # Assigned consumer\n   3) (integer) 45000        # Idle time in ms (e.g., 45 seconds)\n   4) (integer) 1            # Delivery count\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use this to:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Identify which entries are stuck"}),"\n",(0,t.jsx)(n.li,{children:"See how long they\u2019ve been pending (idle time)"}),"\n",(0,t.jsx)(n.li,{children:"See how many times they\u2019ve been delivered (delivery count)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"automatically-claim-stuck-messages-with-xautoclaim",children:"Automatically Claim Stuck Messages with XAUTOCLAIM"}),"\n",(0,t.jsx)(n.p,{children:"Syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XAUTOCLAIM <stream> <group> <consumer> <min-idle-time> <start-id> [COUNT n]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XAUTOCLAIM race:france race-group consumer-B 30000 0-0 COUNT 10\n"})}),"\n",(0,t.jsx)(n.p,{children:"This means:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reassign messages idle for more than 30 seconds"}),"\n",(0,t.jsx)(n.li,{children:"Starting from the oldest message (0-0)"}),"\n",(0,t.jsx)(n.li,{children:"Reassign them to consumer-B"}),"\n",(0,t.jsx)(n.li,{children:"Max 10 entries per call"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"\u27a1 You\u2019ll receive a list of messages to reprocess + the new start ID."}),"\n",(0,t.jsx)(n.h2,{id:"spring-data-redis-example-auto-reclaim-failed-messages",children:"Spring Data Redis Example: Auto-Reclaim Failed Messages"}),"\n",(0,t.jsx)(n.p,{children:"Create spring boot project with following commands, this time we'll use h2 and Spring data JPA as well to process the data."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"spring init -d=web,data-redis,devtools,thymeleaf,lombok \\\n  -g com.example \\\n  -a demo \\\n  -p jar \\\n  --build maven \\\n  xclaim -x\n"})}),"\n",(0,t.jsx)(n.p,{children:"add the following to application.yaml"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"spring:\n  data:\n    redis:\n      host: localhost\n      port: 6379\n  h2:\n    console:\n      enabled: true\n      path: /h2-console\n  datasource:\n    name: example\n    username: sa\n    password:\n    generate-unique-name: false\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n  sql:\n    init:\n      mode: never\n  jpa:\n    open-in-view: false\n    show-sql: true\n    generate-ddl: true\n    properties:\n      hibernate:\n        jdbc:\n          lob:\n            non_contextual_creation: true\n        format_sql: true\n        generate_statistics: true\n    hibernate:\n      ddl-auto: create-drop\n\nlogging:\n  level:\n    root: INFO\n    org:\n      springframework:\n        security: TRACE\n        web:\n          reactive:\n            function:\n              client: DEBUG\n      hibernate:\n        SQL: DEBUG\n        orm:\n          jdbc:\n            bind: TRACE\nstream:\n  idle-timeout-seconds: 900 # 15 minutes\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"There is no standard fixed value for how long to set idle-timeout-seconds \u2014 it entirely depends on how you consume and process your data."}),"\n",(0,t.jsx)(n.p,{children:"You should set the timeout based on the maximum expected processing time for a message in your system, with some extra buffer to avoid premature recovery."}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:'In my case, if the service is responsible for parsing large Excel files, and each job typically takes around 5 to 10 minutes, then I would configure a slightly longer timeout \u2014 say, 15 minutes \u2014 to safely consider the message as "stuck" if it hasn\u2019t been acknowledged in that time.'}),"\n",(0,t.jsx)(n.p,{children:"application.yaml"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"stream:\n  idle-timeout-seconds: 900 # 15 minutes\n"})}),"\n",(0,t.jsx)(n.p,{children:"This allows the system to tolerate long processing times without falsely assuming a failure \u2014 while still enabling automatic recovery for truly stalled consumers."}),"\n",(0,t.jsx)(n.h3,{id:"entity-and-repository",children:"Entity and Repository"}),"\n",(0,t.jsx)(n.p,{children:"Entity - RaceStreamEntity.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@Entity\n@Table(name = "race_stream_entry")\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class RaceStreamEntity {\n\n    @Id\n    @GeneratedValue\n    @UuidGenerator\n    @Setter(AccessLevel.NONE)\n    private UUID id;\n\n    @Column(name = "stream_id", unique = true)\n    private String streamId; // Redis Stream ID (e.g., 1754326272465-45)\n\n    @Column(name = "rider")\n    private String rider;\n\n    @Column(name = "speed")\n    private Double speed;\n\n    @Column(name = "position")\n    private Integer position;\n\n    @Column(name = "location_id")\n    private Integer locationId;\n\n    @Column(name = "received_at")\n    private LocalDateTime receivedAt;\n\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Repository - RaceStreamRepository.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"@Repository\npublic interface RaceStreamRepository extends JpaRepository<RaceStreamEntity, UUID>, JpaSpecificationExecutor<RaceStreamEntity> {\n\n    boolean existsByStreamId(String streamId);\n\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"streamrecoveryservice",children:"StreamRecoveryService"}),"\n",(0,t.jsx)(n.p,{children:"Next, we create a new class in Spring Boot using StreamCommands.xAutoClaim() (low-level access):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class StreamRecoveryService {\n\n    private final StringRedisTemplate redisTemplate;\n    private final RaceStreamRepository repository;\n\n    private static final String STREAM_KEY = "race:france";\n    private static final String GROUP_NAME = "race-group";\n    // A dedicated consumer name for handling recovered messages\n    private static final String RECOVERY_CONSUMER_NAME = "recovery-consumer";\n    private final StreamOperations<String, Object, Object> streamOps = redisTemplate.opsForStream();\n\n    @Value("${stream.idle-timeout-seconds:900}")\n    private long idleTimeoutSeconds;\n\n    /**\n     * Ensures the consumer group exists at startup.\n     * This is idempotent and safe to run every time.\n     */\n    @PostConstruct\n    private void init() {\n        try {\n            // Equivalent to: XGROUP CREATE race:france race-group 0 MKSTREAM\n            redisTemplate.opsForStream().createGroup(STREAM_KEY, ReadOffset.from("0"), GROUP_NAME);\n            log.info("\u2705 Created or verified group \'{}\' on stream \'{}\'", GROUP_NAME, STREAM_KEY);\n        } catch (RedisSystemException e) {\n            // If the group already exists, Redis throws a BUSYGROUP error. We can safely ignore it.\n            if (e.getCause() instanceof RedisBusyException) {\n                log.info("\u2139\ufe0f Group \'{}\' already exists, skipping creation.", GROUP_NAME);\n            } else {\n                log.error("\u274c Could not initialize Redis Stream group", e);\n                throw e;\n            }\n        }\n    }\n\n\n    /**\n     * This scheduled task runs periodically to find and reclaim messages that have been\n     * pending for too long (i.e., were delivered to a consumer that crashed or failed\n     * to acknowledge them). This prevents messages from getting stuck in the stream.\n     */\n    @Scheduled(fixedRate = 60_000) // Run every 60 seconds\n    public void reclaimStuckMessages() {\n        log.info("\u2699\ufe0f Running job to reclaim stuck messages...");\n\n        try {\n            // 1. Check the pending messages for the entire group.\n            // This is equivalent to: XPENDING race:france race-group\n            PendingMessagesSummary summary = streamOps.pending(STREAM_KEY, GROUP_NAME);\n            if (summary == null || summary.getTotalPendingMessages() == 0) {\n                log.info("\u2705 No pending messages to reclaim.");\n                return;\n            }\n\n            log.info("\u2139\ufe0f Found {} total pending messages. Checking for idle ones...", summary.getTotalPendingMessages());\n\n            // 2. Find messages that have been idle for more than 30 seconds.\n            // We check pending messages for any consumer (\'-\') up to a certain count (\'+\').\n            PendingMessages pendingMessages = streamOps.pending(\n                    STREAM_KEY,\n                    GROUP_NAME,\n                    Range.unbounded(), // Check all pending messages\n                    100L // Limit to checking 100 at a time to avoid overload\n            );\n\n            if (pendingMessages.isEmpty()) {\n                return;\n            }\n\n            // 3. Iterate and claim messages that are idle for too long.\n            for (PendingMessage pendingMessage : pendingMessages) {\n                if (pendingMessage.getElapsedTimeSinceLastDelivery().compareTo(Duration.ofSeconds(idleTimeoutSeconds)) > 0) {\n                    log.warn("\ud83d\udea8 Message {} from consumer \'{}\' has been idle for {}. Reclaiming...",\n                            pendingMessage.getId(), pendingMessage.getConsumerName(), pendingMessage.getElapsedTimeSinceLastDelivery());\n\n                    // 4. Claim the message. This changes its ownership to our recovery consumer.\n                    // Equivalent to: XCLAIM race:france race-group recovery-consumer 30000 <message-id>\n                    List<MapRecord<String, Object, Object>> claimedRecords = streamOps.claim(\n                            STREAM_KEY,\n                            GROUP_NAME,\n                            RECOVERY_CONSUMER_NAME,\n                            Duration.ofSeconds(30), // min-idle-time for the claim to succeed\n                            pendingMessage.getId()\n                    );\n\n                    // 5. Process the now-claimed message.\n                    if (!claimedRecords.isEmpty()) {\n                        processAndAcknowledge(claimedRecords);\n                    }\n                }\n            }\n\n        } catch (DataAccessException e) {\n            log.error("\u274c Redis access error during message reclamation: {}", e.getMessage(), e);\n        } catch (Exception e) {\n            log.error("\u274c An unexpected error occurred during message reclamation", e);\n        }\n    }\n\n    /**\n     * Processes a list of records, saves them to the database, and acknowledges them.\n     * This logic can be shared by the main consumer and the recovery service.\n     * @param records The list of MapRecord to process.\n     */\n    private void processAndAcknowledge(List<MapRecord<String, Object, Object>> records) {\n        if (records == null || records.isEmpty()) {\n            return;\n        }\n\n        for (MapRecord<String, Object, Object> record : records) {\n            String streamId = record.getId().getValue();\n            try {\n                // Idempotency check: only process if not already saved.\n                if (!repository.existsByStreamId(streamId)) {\n                    RaceStreamEntity entity = toEntity(record);\n                    repository.save(entity);\n                    log.info("\u2705 Successfully re-processed and saved message {}", streamId);\n\n                    // Acknowledge the message to remove it from the Pending Entries List (PEL).\n                    streamOps.acknowledge(STREAM_KEY, GROUP_NAME, record.getId());\n                    log.info("\ud83d\udc4d Acknowledged message {}", streamId);\n                } else {\n                    // If it\'s already in the DB, it means a previous attempt succeeded\n                    // but failed to acknowledge. We can now safely acknowledge it.\n                    log.warn("\u26a0\ufe0f Message {} was already processed. Acknowledging now.", streamId);\n                    streamOps.acknowledge(STREAM_KEY, GROUP_NAME, record.getId());\n                }\n            } catch (Exception e) {\n                log.error("\u274c Failed to process reclaimed message {}: {}", streamId, e.getMessage(), e);\n                // Decide on a retry strategy or move to a dead-letter queue if needed.\n            }\n        }\n    }\n\n    /**\n     * Maps a Redis Stream record to a JPA entity.\n     */\n    private RaceStreamEntity toEntity(MapRecord<String, Object, Object> record) {\n        Map<Object, Object> valueMap = record.getValue();\n        return RaceStreamEntity.builder()\n                .streamId(record.getId().getValue())\n                .rider(valueMap.getOrDefault("rider", "").toString())\n                .speed(Double.parseDouble(valueMap.getOrDefault("speed", "0").toString()))\n                .position(Integer.parseInt(valueMap.getOrDefault("position", "0").toString()))\n                .locationId(Integer.parseInt(valueMap.getOrDefault("location_id", "0").toString()))\n                .receivedAt(LocalDateTime.now()) // Or parse from a timestamp in the message\n                .build();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"You can call this method periodically (e.g., in a scheduled task) to recover stuck messages."}),"\n",(0,t.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Task"}),(0,t.jsx)(n.th,{children:"Tool/Command"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"List all stuck messages"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"XPENDING stream group - + COUNT"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Reassign idle messages"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"XAUTOCLAIM"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Retry and reprocess"}),(0,t.jsx)(n.td,{children:"Use message ID + logic"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Remove after success"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"XACK"})})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"step-by-step-simulate-stuck-message-for-recovery",children:"Step-by-Step: Simulate Stuck Message for Recovery"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"1. Start Fresh: Flush DB"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"127.0.0.1:6379> FLUSHDB\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"2. Generate 50 Messages with Lua Script"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"redis-cli --eval generate_race.lua race:france , 50\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"3. Create Consumer Group"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"127.0.0.1:6379> XGROUP CREATE race:france race-group 0 MKSTREAM\n"})}),"\n",(0,t.jsx)(n.p,{children:"This sets up the group from the beginning of the stream."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"4. Simulate a consumer processing 10 messages"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"127.0.0.1:6379> XREADGROUP GROUP race-group consumer-B COUNT 10 STREAMS race:france >\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Deliver the first 10 messages to consumer-B"}),"\n",(0,t.jsx)(n.li,{children:"Pending state starts for these 10 entries"}),"\n",(0,t.jsx)(n.li,{children:"No XACK yet = Redis considers them unacknowledged"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"5. Now simulate consumer crash"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Just do nothing \u2014 leave the messages unacknowledged"}),"\n",(0,t.jsx)(n.li,{children:"Close your terminal"}),"\n",(0,t.jsx)(n.li,{children:"Wait 30 minutes (or whatever duration you want to simulate as idle)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"6. Now run your recovery application"})}),"\n",(0,t.jsx)(n.p,{children:"When your Spring Boot application starts, it should periodically check for stuck messages using a recovery scheduler like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"if (pending.getElapsedTimeSinceLastDelivery().compareTo(Duration.ofSeconds(idleTimeoutSeconds)) > 0) {\n    // This message is considered stuck \u2192 claim it\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"These messages can now be claimed, reprocessed, and acknowledged."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"7. Check Pending Messages (Optional)"}),"\nYou can inspect the pending entries via:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"XPENDING race:france race-group\n\nor \n\nXPENDING race:france race-group - + 10\n"})}),"\n",(0,t.jsx)(n.p,{children:"This gives:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'1) (integer) 10\n2) "1754496428424-0"\n3) "1754496428424-9"\n4) 1) 1) "consumer-B"\n      2) "10"\n\nor \n\n127.0.0.1:6379> XPENDING race:france race-group - + 10\n 1) 1) "1754496428424-0"\n    2) "consumer-B"\n    3) (integer) 250220     # Idle time in ms (e.g., 25 seconds)\n    4) (integer) 1\n 2) 1) "1754496428424-1"\n    2) "consumer-B"\n    3) (integer) 250220\n    4) (integer) 1\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"8. Lower Idle Timeout for Testing"}),"\nTo speed up simulation, change the idle timeout config from 15 minutes to just 2 minutes:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# application.yaml\nstream:\n  idle-timeout-seconds: 120 # 2 minutes\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then restart your Spring Boot app and observe the recovery logs:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"..StreamRecoveryService   : \u2705 Successfully re-processed and saved message 1754496428424-9\n..StreamRecoveryService   : \ud83d\udc4d Acknowledged message 1754496428424-9\n..StreamRecoveryService   : \u2699\ufe0f Running job to reclaim stuck messages...\n..StreamRecoveryService   : \u2705 No pending messages to reclaim.\n"})}),"\n",(0,t.jsx)(n.p,{children:"With this setup, you've successfully simulated and verified message recovery from an idle Redis Stream consumer."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(6540);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);